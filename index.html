<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="description" content="audio visualiser — choose from 16 visualisation modes with customisable colours">
<meta name="theme-color" content="#0a0a0a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>visualiser</title>
<style>
  :root {
    --bg: #0a0a0a;
    --fg: #e0e0e0;
    --overlay-bg: rgba(0,0,0,0.85);
    --btn-bg: rgba(255,255,255,0.08);
    --btn-hover: rgba(255,255,255,0.15);
  }
  .light {
    --bg: #f5f5f5;
    --fg: #1a1a1a;
    --overlay-bg: rgba(255,255,255,0.9);
    --btn-bg: rgba(0,0,0,0.06);
    --btn-hover: rgba(0,0,0,0.12);
  }
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; cursor: none !important; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: var(--bg);
    color: var(--fg);
    font-family: 'Garamond', 'EB Garamond', 'Cormorant Garamond', 'Georgia', 'Times New Roman', serif;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    cursor: none;
  }
  canvas {
    display: block;
    width: 100%; height: 100%;
    position: fixed; top: 0; left: 0;
  }

  /* Options toggle button */
  #optBtn {
    position: fixed;
    top: 16px; right: 16px;
    z-index: 100;
    width: 40px; height: 40px;
    background: none;
    border: none;
    color: var(--fg);
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.2s, transform 0.3s;
    opacity: 0.4;
    line-height: 1;
  }
  #optBtn:hover { opacity: 1; }
  #optBtn .arrow {
    display: inline-block;
    transition: transform 0.3s ease;
    font-size: 16px;
  }
  #optBtn.open .arrow { transform: rotate(-90deg); }

  /* Options panel */
  #optPanel {
    position: fixed;
    top: 64px; right: 16px;
    z-index: 99;
    background: var(--overlay-bg);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 12px;
    padding: 8px 0;
    min-width: 180px;
    transform: translateY(-8px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s, transform 0.2s;
    max-height: calc(100vh - 88px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }
  #optPanel.open {
    opacity: 1;
    transform: translateY(0);
    pointer-events: all;
  }
  #optPanel button {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 12px 20px;
    background: none;
    border: none;
    color: var(--fg);
    font-size: 14px;
    font-family: inherit;
    cursor: pointer;
    text-align: left;
    transition: background 0.15s;
  }
  #optPanel button:hover { background: var(--btn-hover); }

  /* Opening dialog */
  #dialog {
    position: fixed; inset: 0;
    z-index: 200;
    background: var(--bg);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 28px;
    transition: opacity 0.4s;
  }
  #dialog.hidden { opacity: 0; pointer-events: none; }
  #dialog .src-heading,
  #dialog .src-row {
    transition: opacity 0.2s ease, transform 0.2s ease;
  }
  #dialog.sensitivity-adjusting .src-heading,
  #dialog.sensitivity-adjusting .src-row {
    opacity: 0;
    transform: translateY(-2px);
    pointer-events: none;
  }
  #dialog.sensitivity-adjusting {
    background: transparent;
  }
  .src-heading {
    font-size: 13px;
    color: var(--fg);
    opacity: 0.4;
    letter-spacing: 0.5px;
    font-weight: 400;
  }
  .src-btn {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: none;
    background: var(--btn-bg);
    color: var(--fg);
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s, transform 0.15s;
    text-align: center;
    font-family: inherit;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .src-btn:hover { background: var(--btn-hover); }
  .src-btn:active { transform: scale(0.96); }
  .src-row {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: center;
  }
  .src-option {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }
  #sensitivityControl {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: min(240px, 72vw);
    margin-top: -8px;
  }
  #sensitivityControl.show { display: flex; }
  .sensitivity-label {
    font-size: 13px;
    color: var(--fg);
    opacity: 0.4;
    letter-spacing: 0.5px;
    font-weight: 400;
    text-transform: none;
    user-select: none;
    cursor: pointer;
  }
  #sensitivitySlider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 2px;
    border-radius: 999px;
    background: var(--btn-hover);
    outline: none;
    opacity: 0.75;
  }
  #sensitivitySlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--fg);
    border: 0;
  }
  #sensitivitySlider::-moz-range-thumb {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--fg);
    border: 0;
  }
  #sensitivitySlider::-moz-range-track {
    height: 2px;
    border-radius: 999px;
    background: var(--btn-hover);
  }
  .src-note {
    display: none;
    max-width: 100px;
    text-align: center;
    font-size: 10px;
    line-height: 1.25;
    letter-spacing: 0.2px;
    color: var(--fg);
    opacity: 0.45;
  }
  @media (pointer: coarse) {
    .src-note.mobile-only { display: block; }
  }

  /* Visualiser picker (after audio connected) */
  #visPicker {
    position: fixed; inset: 0;
    z-index: 190;
    background: var(--bg);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 16px;
    transition: opacity 0.4s;
    padding: 40px 20px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  #visPicker.hidden { opacity: 0; pointer-events: none; }
  #visPickerGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    max-width: 540px;
    width: 100%;
  }
  .pick-item {
    aspect-ratio: 1;
    border-radius: 50%;
    border: none;
    background: var(--btn-bg);
    color: var(--fg);
    font-size: 12px;
    font-family: inherit;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    line-height: 1.15;
    padding: 10px;
    transition: background 0.2s, transform 0.1s;
  }
  .pick-item:hover { background: var(--btn-hover); }
  .pick-item:active { transform: scale(0.96); }
  .pick-random {
    grid-column: 1 / -1;
    aspect-ratio: auto;
    border-radius: 999px;
    padding: 18px;
    font-size: 14px;
    letter-spacing: 0.3px;
  }

  /* Visualiser menu overlay */
  #menuOverlay {
    position: fixed; inset: 0;
    z-index: 150;
    background: var(--overlay-bg);
    backdrop-filter: blur(24px);
    -webkit-backdrop-filter: blur(24px);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  #menuOverlay.open { opacity: 1; pointer-events: all; }
  #menuGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    max-width: 580px;
    width: 90%;
    padding: 20px;
  }
  .menu-item {
    aspect-ratio: 1;
    border-radius: 50%;
    border: none;
    background: var(--btn-bg);
    color: var(--fg);
    font-size: 12px;
    font-family: inherit;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    line-height: 1.15;
    padding: 12px;
    transition: background 0.2s;
  }
  .menu-item.menu-random {
    grid-column: 1 / -1;
    aspect-ratio: auto;
    border-radius: 999px;
    padding: 16px 24px;
    font-size: 13px;
    letter-spacing: 0.3px;
  }
  .menu-item:hover { background: var(--btn-hover); }
  .menu-item.active { background: var(--btn-hover); }
  .overlay-close {
    position: fixed;
    top: max(16px, env(safe-area-inset-top));
    right: max(16px, env(safe-area-inset-right));
    width: 40px; height: 40px;
    background: none;
    border: none;
    color: var(--fg);
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.5;
    transition: opacity 0.2s;
  }
  .overlay-close:hover { opacity: 1; }
  #menuClose { z-index: 160; }
  #colourClose { z-index: 210; }
  .opt-separator {
    height: 1px;
    background: var(--fg);
    opacity: 0.06;
    margin: 4px 20px;
  }
  .opt-footer {
    padding: 8px 20px;
    font-size: 11px;
    color: var(--fg);
    opacity: 0.25;
    text-align: left;
    line-height: 1.6;
  }
  .opt-footer a {
    color: var(--fg);
    text-decoration: none;
    opacity: 0.7;
  }
  .opt-footer a:hover { opacity: 1; }

  /* Colour picker overlay */
  #colourOverlay {
    position: fixed; inset: 0;
    z-index: 200;
    background: var(--overlay-bg);
    backdrop-filter: blur(24px);
    -webkit-backdrop-filter: blur(24px);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 20px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  #colourOverlay.open { opacity: 1; pointer-events: all; }
  .colour-heading {
    font-size: 13px;
    color: var(--fg);
    opacity: 0.4;
    letter-spacing: 0.5px;
  }
  .colour-grid {
    display: grid;
    grid-template-columns: repeat(3, 40px);
    gap: 16px;
    justify-content: center;
  }
  .colour-option {
    width: 40px; height: 40px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
    padding: 0;
    position: relative;
    background: none;
  }
  .colour-option:hover { transform: scale(1.12); }
  .colour-option:active { transform: scale(0.95); }
  .colour-option.active {
    box-shadow: 0 0 0 3px var(--bg), 0 0 0 5.5px rgba(128,128,128,0.5);
  }
  .colour-swatch {
    width: 100%; height: 100%;
    border-radius: 50%;
    display: block;
  }

  /* Hide controls briefly on idle */
  .controls-hidden #optBtn { opacity: 0 !important; transition: opacity 0.8s; }
  .controls-hidden #cursor { opacity: 0 !important; transition: opacity 0.8s; }
  .controls-hidden #visNameHint { opacity: 0 !important; transition: opacity 0.8s; }

  #visNameHint {
    position: fixed;
    top: 14px;
    left: 50%;
    transform: translateX(-50%) translateY(-4px);
    z-index: 120;
    pointer-events: none;
    color: var(--fg);
    font-size: 11px;
    letter-spacing: 0.08em;
    text-transform: lowercase;
    opacity: 0;
    transition: opacity 0.28s ease, transform 0.28s ease;
  }
  #visNameHint.show {
    opacity: 0.62;
    transform: translateX(-50%) translateY(0);
  }

  /* Custom cursor */
  #cursor {
    position: fixed;
    z-index: 9999;
    pointer-events: none;
    width: 20px; height: 20px;
    margin-left: -10px; margin-top: -10px;
    border: 1.5px solid var(--fg);
    border-radius: 50%;
    opacity: 0.4;
    transition: opacity 0.2s;
    display: none;
  }
  #cursor.touch-hidden { display: none !important; }
  @media (pointer: coarse) {
    #cursor { display: none !important; }
  }
  #cursor::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 4px; height: 4px;
    margin-left: -2px; margin-top: -2px;
    background: var(--fg);
    border-radius: 50%;
    opacity: 0.7;
    transform: scale(1);
    transition: transform 0.14s ease;
  }
  #cursor.clicking::after { transform: scale(1.65); }

  @media (max-width: 480px) {
    #optPanel { right: 8px; top: 60px; }
    #optBtn { top: 12px; right: 12px; width: 36px; height: 36px; }
    .src-btn { width: 100px; height: 100px; font-size: 13px; }
    .src-row { flex-direction: row; gap: 12px; }
    #visPickerGrid { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px; }
    .pick-item { font-size: 11px; padding: 8px; }
    .pick-random { padding: 14px; font-size: 13px; }
    .colour-option { width: 36px; height: 36px; }
    .colour-grid { grid-template-columns: repeat(3, 36px); gap: 12px; }
  }

  @media (max-width: 820px), (max-height: 760px) {
    #visPicker {
      align-items: flex-start;
      justify-content: center;
      padding-top: calc(56px + env(safe-area-inset-top));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
    }
    #visPickerGrid {
      width: min(100%, 540px);
      max-width: none;
      grid-template-columns: repeat(auto-fit, minmax(76px, 1fr));
      gap: 8px;
      padding: 6px;
    }
    .pick-item { font-size: 11px; padding: 8px; }
    .pick-random { padding: 12px; font-size: 12px; }

    #menuOverlay {
      align-items: flex-start;
      justify-content: center;
      padding-top: calc(56px + env(safe-area-inset-top));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      padding-left: 10px;
      padding-right: 10px;
    }
    #menuGrid {
      width: min(100%, 560px);
      max-width: none;
      grid-template-columns: repeat(auto-fit, minmax(76px, 1fr));
      gap: 8px;
      padding: 6px;
    }
    .menu-item { font-size: 11px; padding: 9px; }
    .menu-item.menu-random { padding: 12px 16px; font-size: 12px; }
  }
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="cursor"></div>
<div id="visNameHint" aria-live="polite"></div>

<!-- Options button -->
<button id="optBtn" aria-label="Options"><span class="arrow">&#x276F;</span></button>

<!-- Options panel -->
<div id="optPanel">
  <button id="optFullscreen">fullscreen</button>
  <button id="optTheme">light mode</button>
  <button id="optNext">next</button>
  <button id="optMenu">menu</button>
  <button id="optSource">source</button>
  <button id="optColour">colour</button>
  <button id="optShare">share</button>
  <div class="opt-separator"></div>
  <div class="opt-footer">
    <a href="https://buymeacoffee.com/samiainstevens" target="_blank" rel="noopener">buy me a coffee</a><br>
    <a href="https://www.samiainstevens.com" target="_blank" rel="noopener">&copy; sam stevens 2026</a>
  </div>
</div>

<!-- Opening dialog -->
<div id="dialog">
  <span class="src-heading">choose audio source</span>
  <div class="src-row">
    <div class="src-option">
      <button class="src-btn" id="btnMic">microphone</button>
    </div>
    <div class="src-option">
      <button class="src-btn" id="btnSystem">device sound</button>
      <span class="src-note mobile-only">may not work on mobile devices</span>
    </div>
  </div>
  <div id="sensitivityControl" aria-label="sensitivity control">
    <span id="sensitivityLabel" class="sensitivity-label" role="button" tabindex="0">sensitivity</span>
    <input id="sensitivitySlider" type="range" min="0" max="1" step="0.01" value="0.5">
  </div>
</div>

<!-- Visualiser picker -->
<div id="visPicker" class="hidden">
  <div id="visPickerGrid"></div>
</div>

<!-- Visualiser menu overlay -->
<div id="menuOverlay">
  <button class="overlay-close" id="menuClose">&#x2715;</button>
  <div id="menuGrid"></div>
</div>

<!-- Colour picker overlay -->
<div id="colourOverlay">
  <button class="overlay-close" id="colourClose">&#x2715;</button>
  <span class="colour-heading">choose colour</span>
  <div class="colour-grid" id="colourGrid"></div>
</div>

<script>
(() => {
  'use strict';

  // ── State ──
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const menuOverlay = document.getElementById('menuOverlay');
  const colourOverlay = document.getElementById('colourOverlay');
  let audioCtx, analyser, dataArray, freqArray, source, currentStream;
  let balancedFreqArray;
  let currentVis = 0;
  let running = false;
  let changingSource = false;
  let lightMode = false;
  let colourMode = 'rainbow';
  let sensitivity = 1;
  let idleTimer, controlsHidden = false;
  const fftSize = 2048;
  const SENSITIVITY_MIN = 0.5;
  const DEFAULT_SENSITIVITY = 1;
  const SENSITIVITY_MAX = 2.2;
  const SENSITIVITY_UI_DEFAULT = 0.5;
  const pointerField = {
    x: 0,
    y: 0,
    active: false,
    strength: 0,
    touchPointerId: null
  };
  let wakeLockSentinel = null;
  let wakeLockRetryTimer = null;
  const supportsWakeLock = typeof navigator !== 'undefined' && 'wakeLock' in navigator;

  // ── Visualisers ──
  const visualisers = [
    { name: 'bars', fn: drawBars },
    { name: 'waveform', fn: drawWaveform },
    { name: 'radial', fn: drawRadial },
    { name: 'particles', fn: drawParticles },
    { name: 'nightingale', fn: drawNightingale },
    { name: 'spectrum', fn: drawSpectrumRing },
    { name: 'terrain', fn: drawTerrain },
    { name: 'starfield', fn: drawStarfield },
    { name: 'aurora', fn: drawAurora },
    { name: 'kaleidoscope', fn: drawKaleidoscope },
    { name: 'raindrops', fn: drawRaindrops },
    { name: 'swirls', fn: drawSwirls },
    { name: 'fog', fn: drawDancingCircles },
    { name: 'fireworks', fn: drawFireworks },
    { name: 'polygraph', fn: drawPolygraph },
    { name: 'decibels', fn: drawDecibels },
  ];

  // ── Particle state ──
  let particles = [];
  let particlesSpawnAccumulator = 0;
  const MAX_PARTICLES = 170;

  // ── Bars state ──
  let barsVariant = 0;
  const BARS_VARIANT_COUNT = 4;
  let barsSmoothed = null;
  let mirrorBarsSmoothed = null;
  const FREQ_BARS_SMOOTHING = 0.22;
  const MIRROR_BARS_SMOOTHING = 0.2;

  // ── Terrain state ──
  let terrainHistory = [];
  const TERRAIN_ROWS = 60;
  let terrainFrameCount = 0;

  // ── Starfield state ──
  let stars = [];
  const NUM_STARS = 300;
  let starfieldOriginX = null;
  let starfieldOriginY = null;
  let starfieldMouseFollow = false;
  let starfieldTouchDragging = false;
  let starfieldTouchPointerId = null;
  let starfieldReturnActive = false;
  let starfieldReturnStart = 0;
  let starfieldReturnFromX = 0;
  let starfieldReturnFromY = 0;
  const STARFIELD_RETURN_DURATION_MS = 500;
  function initStars() {
    stars = [];
    for (let i = 0; i < NUM_STARS; i++) {
      stars.push({
        x: (Math.random() - 0.5) * 2,
        y: (Math.random() - 0.5) * 2,
        z: Math.random()
      });
    }
  }
  initStars();

  function ensureStarfieldOrigin(w, h) {
    if (Number.isFinite(starfieldOriginX) && Number.isFinite(starfieldOriginY)) return;
    starfieldOriginX = w / 2;
    starfieldOriginY = h / 2;
  }

  function setStarfieldOriginFromClient(clientX, clientY) {
    const p = getCanvasPoint(clientX, clientY);
    starfieldOriginX = p.x;
    starfieldOriginY = p.y;
    starfieldReturnActive = false;
  }

  function beginStarfieldReturn() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    ensureStarfieldOrigin(w, h);
    starfieldReturnFromX = starfieldOriginX;
    starfieldReturnFromY = starfieldOriginY;
    starfieldReturnStart = performance.now();
    starfieldReturnActive = true;
  }

  function stopStarfieldTouchDrag(pointerId = null) {
    if (!starfieldTouchDragging) return;
    if (pointerId !== null && pointerId !== starfieldTouchPointerId) return;
    starfieldTouchDragging = false;
    starfieldTouchPointerId = null;
    beginStarfieldReturn();
  }

  function updateStarfieldOrigin(w, h) {
    ensureStarfieldOrigin(w, h);
    if (starfieldMouseFollow || starfieldTouchDragging) return;
    if (!starfieldReturnActive) return;
    const t = Math.min(1, (performance.now() - starfieldReturnStart) / STARFIELD_RETURN_DURATION_MS);
    const easeOut = 1 - Math.pow(1 - t, 3);
    const cx = w / 2;
    const cy = h / 2;
    starfieldOriginX = starfieldReturnFromX + (cx - starfieldReturnFromX) * easeOut;
    starfieldOriginY = starfieldReturnFromY + (cy - starfieldReturnFromY) * easeOut;
    if (t >= 1) {
      starfieldOriginX = cx;
      starfieldOriginY = cy;
      starfieldReturnActive = false;
    }
  }

  async function requestWakeLock() {
    if (!running) return;
    if (document.visibilityState !== 'visible') return;
    if (!supportsWakeLock || wakeLockSentinel) return;
    try {
      wakeLockSentinel = await navigator.wakeLock.request('screen');
      wakeLockSentinel.addEventListener('release', () => {
        wakeLockSentinel = null;
        if (wakeLockRetryTimer) {
          clearTimeout(wakeLockRetryTimer);
          wakeLockRetryTimer = null;
        }
        // Try to restore lock if browser/OS releases it unexpectedly.
        if (running && document.visibilityState === 'visible') {
          wakeLockRetryTimer = setTimeout(() => {
            wakeLockRetryTimer = null;
            requestWakeLock();
          }, 250);
        }
      }, { once: true });
    } catch (_) {
      // Wake lock can fail due to browser/device constraints; fail silently.
    }
  }

  function releaseWakeLock() {
    if (wakeLockRetryTimer) {
      clearTimeout(wakeLockRetryTimer);
      wakeLockRetryTimer = null;
    }
    if (!wakeLockSentinel) return;
    wakeLockSentinel.release().catch(() => {});
    wakeLockSentinel = null;
  }

  // ── Audio Setup ──
  async function initAudio(mode) {
    try {
      // Stop previous stream if changing source
      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
      }
      if (source) { source.disconnect(); source = null; }
      if (audioCtx) { await audioCtx.close(); audioCtx = null; }

      let stream;
      if (mode === 'mic') {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      } else {
        if (!navigator.mediaDevices || typeof navigator.mediaDevices.getDisplayMedia !== 'function') {
          alert('device sound capture is not supported in this browser. try microphone instead.');
          return;
        }
        stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        stream.getVideoTracks().forEach(t => t.stop());
        if (stream.getAudioTracks().length === 0) {
          alert('No audio track found. Make sure to share a tab or screen with audio.');
          return;
        }
      }

      currentStream = stream;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = fftSize;
      analyser.smoothingTimeConstant = 0.8;

      source = audioCtx.createMediaStreamSource(stream);
      source.connect(analyser);

      dataArray = new Uint8Array(analyser.frequencyBinCount);
      freqArray = new Uint8Array(analyser.frequencyBinCount);
      balancedFreqArray = new Float32Array(analyser.frequencyBinCount);

      document.getElementById('dialog').classList.add('hidden');

      // If changing source, skip picker and go straight back to visualiser
      if (changingSource) {
        changingSource = false;
        updateSensitivityControlVisibility();
        if (!running) { running = true; resize(); animate(); }
        requestWakeLock();
      } else {
        // Show visualiser picker
        showVisPicker();
      }
    } catch (e) {
      console.error(e);
      if (changingSource) {
        changingSource = false;
        document.getElementById('dialog').classList.add('hidden');
        updateSensitivityControlVisibility();
      }
      if (e.name !== 'NotAllowedError') {
        alert('could not access audio: ' + e.message);
      }
    }
  }

  // ── Canvas resize ──
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);

  // ── Animation loop ──
  function animate() {
    if (!running) return;
    requestAnimationFrame(animate);
    if (!analyser || !dataArray || !freqArray) return;

    analyser.getByteTimeDomainData(dataArray);
    analyser.getByteFrequencyData(freqArray);
    if (Math.abs(sensitivity - 1) > 0.001) {
      const gain = sensitivity;
      for (let i = 0; i < freqArray.length; i++) {
        const boosted = freqArray[i] * gain;
        freqArray[i] = boosted > 255 ? 255 : boosted;
      }
      for (let i = 0; i < dataArray.length; i++) {
        const shifted = (dataArray[i] - 128) * gain + 128;
        dataArray[i] = shifted < 0 ? 0 : shifted > 255 ? 255 : shifted;
      }
    }

    if (!balancedFreqArray || balancedFreqArray.length !== freqArray.length) {
      balancedFreqArray = new Float32Array(freqArray.length);
    }
    const last = Math.max(1, freqArray.length - 1);
    for (let i = 0; i < freqArray.length; i++) {
      const pos = i / last;
      const iL1 = i > 0 ? i - 1 : i;
      const iR1 = i < last ? i + 1 : i;
      const iL2 = i > 1 ? i - 2 : iL1;
      const iR2 = i < last - 1 ? i + 2 : iR1;
      const c = (freqArray[i] || 0) / 255;
      const n1 = ((freqArray[iL1] || 0) + (freqArray[iR1] || 0)) / (255 * 2);
      const n2 = ((freqArray[iL2] || 0) + (freqArray[iR2] || 0)) / (255 * 2);
      const blended = Math.min(1, c * 0.56 + n1 * 0.3 + n2 * 0.14);
      const shaped = Math.pow(blended, 0.92);
      const eqGain = 0.58 + Math.pow(pos, 0.88) * 2.1;
      balancedFreqArray[i] = Math.min(255, shaped * eqGain * 255);
    }

    const w = window.innerWidth;
    const h = window.innerHeight;
    updatePointerFieldStrength();

    // Fireworks uses its own fade-overlay; skip full clear for it
    if (visualisers[currentVis].name !== 'fireworks') {
      ctx.fillStyle = lightMode ? '#f5f5f5' : '#0a0a0a';
      ctx.fillRect(0, 0, w, h);
    }

    visualisers[currentVis].fn(w, h);
  }

  // ── Helper: get average level ──
  function getLevel() {
    let sum = 0;
    for (let i = 0; i < freqArray.length; i++) sum += freqArray[i];
    return sum / freqArray.length / 255;
  }

  // Weighted sampler for visual mappings.
  // Uses an equalized frequency view to avoid heavy start-weighting.
  function sampleFreq(t, band = 0.78, gamma = 0.9) {
    const clampedT = Math.max(0, Math.min(1, t));
    const clampedBand = Math.max(0.05, Math.min(1, band));
    const maxIdx = Math.max(1, Math.floor(freqArray.length * clampedBand) - 1);
    const effectiveGamma = Math.max(0.75, gamma * 1.15);
    const mapped = Math.pow(clampedT, effectiveGamma) * maxIdx;
    const i0 = Math.floor(mapped);
    const i1 = Math.min(maxIdx, i0 + 1);
    const frac = mapped - i0;
    const source = balancedFreqArray || freqArray;
    const v0 = source[i0] || 0;
    const v1 = source[i1] || v0;
    return ((1 - frac) * v0 + frac * v1) / 255;
  }

  function updatePointerFieldStrength() {
    let target = 0;
    if (pointerField.active) {
      const rect = canvas.getBoundingClientRect();
      const clientX = rect.left + pointerField.x;
      const clientY = rect.top + pointerField.y;
      target = canUseCanvasInteraction(clientX, clientY) ? 1 : 0;
    }
    pointerField.strength += (target - pointerField.strength) * 0.14;
    if (target === 0 && pointerField.strength < 0.001) {
      pointerField.strength = 0;
    }
  }

  // ── Helper: color based on mode ──
  function fg(alpha = 1) {
    return lightMode ? `rgba(20,20,20,${alpha})` : `rgba(230,230,230,${alpha})`;
  }
  function hslColor(h, s, l, a = 1) {
    if (colourMode === 'monochrome') {
      return `hsla(0,0%,${l}%,${a})`;
    }
    if (colourMode !== 'rainbow') {
      // Fixed hue pastel mode
      const pastelHues = {
        'rose': 350, 'peach': 25, 'lavender': 270,
        'mint': 155, 'sky': 200, 'lemon': 50, 'lilac': 290
      };
      const fixedHue = pastelHues[colourMode] || 0;
      return `hsla(${fixedHue},${Math.min(s, 55)}%,${Math.max(l, 65)}%,${a})`;
    }
    return `hsla(${h},${s}%,${l}%,${a})`;
  }

  function roundedRectPath(x, y, width, height, radius) {
    if (typeof ctx.roundRect === 'function') {
      ctx.roundRect(x, y, width, height, radius);
      return;
    }
    const r = Math.max(0, Math.min(radius, width / 2, height / 2));
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + width - r, y);
    ctx.arcTo(x + width, y, x + width, y + r, r);
    ctx.lineTo(x + width, y + height - r);
    ctx.arcTo(x + width, y + height, x + width - r, y + height, r);
    ctx.lineTo(x + r, y + height);
    ctx.arcTo(x, y + height, x, y + height - r, r);
    ctx.lineTo(x, y + r);
    ctx.arcTo(x, y, x + r, y, r);
    ctx.closePath();
  }

  // ═══════════════════════════════
  //  VISUALISER 1: Bars
  // ═══════════════════════════════
  function drawBars(w, h) {
    const variant = barsVariant % BARS_VARIANT_COUNT;
    if (variant >= 2) {
      drawBarsMirror(w, h, variant === 3);
      return;
    }

    const bars = Math.min(128, freqArray.length);
    const barW = w / bars;
    const baseHue = (Date.now() / 50) % 360;

    if (!barsSmoothed || barsSmoothed.length !== bars) {
      barsSmoothed = new Float32Array(bars);
      for (let i = 0; i < bars; i++) barsSmoothed[i] = freqArray[i] / 255;
    } else {
      for (let i = 0; i < bars; i++) {
        const target = freqArray[i] / 255;
        barsSmoothed[i] += (target - barsSmoothed[i]) * FREQ_BARS_SMOOTHING;
      }
    }

    for (let i = 0; i < bars; i++) {
      const val = barsSmoothed[i];
      const barH = val * h * 0.85;
      const hue = (baseHue + i * 2) % 360;
      const lightness = lightMode ? 35 : 60;

      ctx.fillStyle = hslColor(hue, 70, lightness, 0.8);
      const y = variant === 1 ? 0 : h - barH;
      ctx.fillRect(i * barW, y, barW - 1, barH);
    }
  }

  function drawBarsMirror(w, h, vertical = true) {
    const bars = Math.min(96, freqArray.length);
    const cx = w / 2;
    const cy = h / 2;
    const baseHue = (Date.now() / 60) % 360;

    if (!mirrorBarsSmoothed || mirrorBarsSmoothed.length !== bars) {
      mirrorBarsSmoothed = new Float32Array(bars);
      for (let i = 0; i < bars; i++) mirrorBarsSmoothed[i] = freqArray[i] / 255;
    } else {
      for (let i = 0; i < bars; i++) {
        const target = freqArray[i] / 255;
        mirrorBarsSmoothed[i] += (target - mirrorBarsSmoothed[i]) * MIRROR_BARS_SMOOTHING;
      }
    }

    for (let i = 0; i < bars; i++) {
      const val = mirrorBarsSmoothed[i];
      const hue = (baseHue + i * 2.5) % 360;
      const lightness = lightMode ? 35 : 60;

      ctx.fillStyle = hslColor(hue, 65, lightness, 0.75);
      if (vertical) {
        const barW = w / bars;
        const barH = val * h * 0.42;
        ctx.fillRect(i * barW, cy - barH, barW - 1, barH);
        ctx.fillStyle = hslColor(hue, 65, lightness, 0.4);
        ctx.fillRect(i * barW, cy, barW - 1, barH);
      } else {
        const barH = h / bars;
        const barLen = val * w * 0.42;
        ctx.fillRect(cx - barLen, i * barH, barLen, barH - 1);
        ctx.fillStyle = hslColor(hue, 65, lightness, 0.4);
        ctx.fillRect(cx, i * barH, barLen, barH - 1);
      }
    }

    ctx.beginPath();
    if (vertical) {
      ctx.moveTo(0, cy);
      ctx.lineTo(w, cy);
    } else {
      ctx.moveTo(cx, 0);
      ctx.lineTo(cx, h);
    }
    ctx.strokeStyle = fg(0.1);
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // ═══════════════════════════════
  //  VISUALISER 2: Waveform
  // ═══════════════════════════════
  let wfSmoothed = null;
  let waveformVertical = false;
  function drawWaveform(w, h) {
    const baseHue = (Date.now() / 120) % 360;

    // Smooth the waveform data to reduce jitter
    if (!wfSmoothed || wfSmoothed.length !== dataArray.length) {
      wfSmoothed = new Float32Array(dataArray.length);
      for (let i = 0; i < dataArray.length; i++) wfSmoothed[i] = dataArray[i];
    } else {
      for (let i = 0; i < dataArray.length; i++) {
        wfSmoothed[i] += (dataArray[i] - wfSmoothed[i]) * 0.18;
      }
    }

    // Draw multiple layered waveforms
    const step = 3;
    for (let layer = 0; layer < 3; layer++) {
      ctx.beginPath();
      const sliceW = w / (dataArray.length / step);
      const sliceH = h / (dataArray.length / step);
      const offset = layer * 0.1;
      const hue = (baseHue + layer * 40) % 360;
      const lightness = lightMode ? 40 : 65;
      ctx.strokeStyle = hslColor(hue, 60, lightness, 0.6 - layer * 0.15);
      ctx.lineWidth = 2.5 - layer * 0.5;

      for (let i = 0; i < dataArray.length; i += step) {
        const v = (wfSmoothed[i] / 128.0) - 1 + offset;
        const x = waveformVertical ? (v * w * 0.3) + w / 2 : (i / step) * sliceW;
        const y = waveformVertical ? (i / step) * sliceH : (v * h * 0.3) + h / 2;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 3: Radial
  // ═══════════════════════════════
  let radialRotation = 0;
  let radialSpinSpeed = 0;
  let radialSpinEnabled = false;
  let radialSpinStopping = false;
  let radialSpinStopAngle = null;
  let radialStopClickCount = 0;
  let radialLastUpdate = performance.now();
  const RADIAL_SPIN_MAX_SPEED = 0.72;
  const RADIAL_SPIN_ACCEL = 0.7;
  const RADIAL_SPIN_DECEL = RADIAL_SPIN_ACCEL;
  const RADIAL_TAU = Math.PI * 2;
  const RADIAL_STOP_SNAP_CLICKS = 1;

  function updateRadialSpin() {
    const now = performance.now();
    const dt = Math.min(0.05, Math.max(0.001, (now - radialLastUpdate) / 1000));
    radialLastUpdate = now;

    if (radialSpinStopping && radialSpinStopAngle !== null) {
      const remaining = Math.max(0, radialRotation - radialSpinStopAngle);
      if (remaining <= 0.0005) {
        radialRotation = radialSpinStopAngle;
        radialSpinSpeed = 0;
        radialSpinEnabled = false;
        radialSpinStopping = false;
        radialSpinStopAngle = null;
        radialStopClickCount = 0;
        return;
      }

      const decelDistance = (RADIAL_SPIN_MAX_SPEED * RADIAL_SPIN_MAX_SPEED) / (2 * RADIAL_SPIN_DECEL);
      const desiredSpeed = remaining > decelDistance
        ? RADIAL_SPIN_MAX_SPEED
        : Math.sqrt(2 * RADIAL_SPIN_DECEL * remaining);

      if (radialSpinSpeed < desiredSpeed) {
        radialSpinSpeed = Math.min(desiredSpeed, radialSpinSpeed + RADIAL_SPIN_ACCEL * dt);
      } else if (radialSpinSpeed > desiredSpeed) {
        radialSpinSpeed = Math.max(desiredSpeed, radialSpinSpeed - RADIAL_SPIN_DECEL * dt);
      }

      radialRotation -= radialSpinSpeed * dt;
      if (radialRotation <= radialSpinStopAngle + 0.0005) {
        radialRotation = radialSpinStopAngle;
        radialSpinSpeed = 0;
        radialSpinEnabled = false;
        radialSpinStopping = false;
        radialSpinStopAngle = null;
        radialStopClickCount = 0;
      }
      return;
    }

    const desiredSpeed = radialSpinEnabled ? RADIAL_SPIN_MAX_SPEED : 0;
    if (radialSpinSpeed < desiredSpeed) {
      radialSpinSpeed = Math.min(desiredSpeed, radialSpinSpeed + RADIAL_SPIN_ACCEL * dt);
    } else if (radialSpinSpeed > desiredSpeed) {
      radialSpinSpeed = Math.max(desiredSpeed, radialSpinSpeed - RADIAL_SPIN_DECEL * dt);
    }

    if (radialSpinSpeed > 0.0001) {
      radialRotation -= radialSpinSpeed * dt;
    }
  }

  function toggleRadialSpin() {
    radialLastUpdate = performance.now();
    if (!radialSpinEnabled && !radialSpinStopping && radialSpinSpeed <= 0.001) {
      radialSpinEnabled = true;
      radialStopClickCount = 0;
      return;
    }
    if (radialSpinStopping) {
      radialStopClickCount++;
      if (radialStopClickCount >= RADIAL_STOP_SNAP_CLICKS) {
        const snapAngle = radialSpinStopAngle !== null
          ? radialSpinStopAngle
          : Math.floor(radialRotation / RADIAL_TAU) * RADIAL_TAU;
        radialRotation = snapAngle;
        radialSpinSpeed = 0;
        radialSpinEnabled = false;
        radialSpinStopping = false;
        radialSpinStopAngle = null;
        radialStopClickCount = 0;
      }
      return;
    }

    radialSpinEnabled = false;
    radialSpinStopping = true;
    radialStopClickCount = 0;
    // Stop at the next completed full turn (<= 1 additional rotation).
    radialSpinStopAngle = Math.floor(radialRotation / RADIAL_TAU) * RADIAL_TAU;
    if (radialSpinStopAngle >= radialRotation - 0.0005) {
      radialSpinStopAngle -= RADIAL_TAU;
    }
  }

  function drawRadial(w, h) {
    updateRadialSpin();

    const cx = w / 2;
    const cy = h / 2;
    const radius = Math.min(w, h) * 0.25;
    const bars = 180;
    const baseHue = (Date.now() / 60) % 360;
    const level = getLevel();

    // Glow circle
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius + 100);
    const glowAlpha = level * 0.15;
    grad.addColorStop(0, hslColor(baseHue, 70, lightMode ? 50 : 60, glowAlpha));
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    for (let i = 0; i < bars; i++) {
      const angle = (i / bars) * Math.PI * 2 - Math.PI / 2 + radialRotation;
      const val = sampleFreq(i / (bars - 1), 0.78, 0.9);
      const len = val * radius * 1.2;
      const hue = (baseHue + i * 2) % 360;
      const lightness = lightMode ? 35 : 65;

      const x1 = cx + Math.cos(angle) * (radius * 0.5);
      const y1 = cy + Math.sin(angle) * (radius * 0.5);
      const x2 = cx + Math.cos(angle) * (radius * 0.5 + len);
      const y2 = cy + Math.sin(angle) * (radius * 0.5 + len);

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = hslColor(hue, 70, lightness, 0.7);
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 4: Particles
  // ═══════════════════════════════
  function drawParticles(w, h) {
    const level = getLevel();
    const baseHue = (Date.now() / 50) % 360;

    // Spawn steadily with an accumulator to avoid bursty flicker.
    particlesSpawnAccumulator += 0.36 + level * 3.6;
    let spawnCount = Math.floor(particlesSpawnAccumulator);
    if (spawnCount > 0) particlesSpawnAccumulator -= spawnCount;
    spawnCount = Math.min(spawnCount, 7);

    for (let i = 0; i < spawnCount && particles.length < MAX_PARTICLES; i++) {
      particles.push({
        x: Math.random() * w,
        y: Math.random() * h,
        vx: (Math.random() - 0.5) * (1.6 + level * 4.2),
        vy: (Math.random() - 0.5) * (1.6 + level * 4.2),
        life: 1,
        age: 0,
        fadeIn: 0.07 + Math.random() * 0.08,
        decay: 0.002 + Math.random() * 0.0035,
        size: 5 + Math.random() * 7,
        hue: (baseHue + Math.random() * 60) % 360
      });
    }

    // Update & draw particles
    particles = particles.filter(p => p.life > 0);
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.992;
      p.vy *= 0.992;
      p.life -= p.decay;
      p.age += p.decay * 3.2;
      if (p.life <= 0) continue;

      const appear = Math.min(1, p.age / p.fadeIn);
      const renderLife = p.life * appear;
      if (renderLife <= 0.0005) continue;

      const lightness = lightMode ? 35 : 65;
      const radius = Math.max(0.8, p.size * (0.2 + renderLife * 0.8));
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = hslColor(p.hue, 70, lightness, (0.18 + p.life * 0.62) * appear);
      ctx.fill();
    }

    // Draw connecting lines between close particles
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const p1 = particles[i];
        const p2 = particles[j];
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 150) {
          const p1Appear = Math.min(1, p1.age / p1.fadeIn);
          const p2Appear = Math.min(1, p2.age / p2.fadeIn);
          const pairLife = Math.min(p1.life * p1Appear, p2.life * p2Appear);
          const alpha = (1 - dist / 150) * 0.24 * pairLife;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.strokeStyle = fg(alpha);
          ctx.lineWidth = 0.6;
          ctx.stroke();
        }
      }
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 5: Nightingale
  // ═══════════════════════════════
  let nightingaleRotation = 0;
  let nightingaleSpinSpeed = 0;
  let nightingaleSpinEnabled = false;
  let nightingaleSpinStopping = false;
  let nightingaleSpinStopAngle = null;
  let nightingaleStopClickCount = 0;
  let nightingaleLastUpdate = performance.now();
  let nightingaleOuterSmoothed = null;
  let nightingaleInnerSmoothed = null;
  let nightingaleLagBuffer = null;
  const NIGHTINGALE_OUTER_SMOOTHING = 0.18;
  const NIGHTINGALE_INNER_SMOOTHING = 0.12;

  function updateNightingaleSpin() {
    const now = performance.now();
    const dt = Math.min(0.05, Math.max(0.001, (now - nightingaleLastUpdate) / 1000));
    nightingaleLastUpdate = now;

    if (nightingaleSpinStopping && nightingaleSpinStopAngle !== null) {
      const remaining = Math.max(0, nightingaleRotation - nightingaleSpinStopAngle);
      if (remaining <= 0.0005) {
        nightingaleRotation = nightingaleSpinStopAngle;
        nightingaleSpinSpeed = 0;
        nightingaleSpinEnabled = false;
        nightingaleSpinStopping = false;
        nightingaleSpinStopAngle = null;
        nightingaleStopClickCount = 0;
        return;
      }

      const decelDistance = (RADIAL_SPIN_MAX_SPEED * RADIAL_SPIN_MAX_SPEED) / (2 * RADIAL_SPIN_DECEL);
      const desiredSpeed = remaining > decelDistance
        ? RADIAL_SPIN_MAX_SPEED
        : Math.sqrt(2 * RADIAL_SPIN_DECEL * remaining);

      if (nightingaleSpinSpeed < desiredSpeed) {
        nightingaleSpinSpeed = Math.min(desiredSpeed, nightingaleSpinSpeed + RADIAL_SPIN_ACCEL * dt);
      } else if (nightingaleSpinSpeed > desiredSpeed) {
        nightingaleSpinSpeed = Math.max(desiredSpeed, nightingaleSpinSpeed - RADIAL_SPIN_DECEL * dt);
      }

      nightingaleRotation -= nightingaleSpinSpeed * dt;
      if (nightingaleRotation <= nightingaleSpinStopAngle + 0.0005) {
        nightingaleRotation = nightingaleSpinStopAngle;
        nightingaleSpinSpeed = 0;
        nightingaleSpinEnabled = false;
        nightingaleSpinStopping = false;
        nightingaleSpinStopAngle = null;
        nightingaleStopClickCount = 0;
      }
      return;
    }

    const desiredSpeed = nightingaleSpinEnabled ? RADIAL_SPIN_MAX_SPEED : 0;
    if (nightingaleSpinSpeed < desiredSpeed) {
      nightingaleSpinSpeed = Math.min(desiredSpeed, nightingaleSpinSpeed + RADIAL_SPIN_ACCEL * dt);
    } else if (nightingaleSpinSpeed > desiredSpeed) {
      nightingaleSpinSpeed = Math.max(desiredSpeed, nightingaleSpinSpeed - RADIAL_SPIN_DECEL * dt);
    }

    if (nightingaleSpinSpeed > 0.0001) {
      nightingaleRotation -= nightingaleSpinSpeed * dt;
    }
  }

  function toggleNightingaleSpin() {
    nightingaleLastUpdate = performance.now();
    if (!nightingaleSpinEnabled && !nightingaleSpinStopping && nightingaleSpinSpeed <= 0.001) {
      nightingaleSpinEnabled = true;
      nightingaleStopClickCount = 0;
      return;
    }
    if (nightingaleSpinStopping) {
      nightingaleStopClickCount++;
      if (nightingaleStopClickCount >= RADIAL_STOP_SNAP_CLICKS) {
        const snapAngle = nightingaleSpinStopAngle !== null
          ? nightingaleSpinStopAngle
          : Math.floor(nightingaleRotation / RADIAL_TAU) * RADIAL_TAU;
        nightingaleRotation = snapAngle;
        nightingaleSpinSpeed = 0;
        nightingaleSpinEnabled = false;
        nightingaleSpinStopping = false;
        nightingaleSpinStopAngle = null;
        nightingaleStopClickCount = 0;
      }
      return;
    }

    nightingaleSpinEnabled = false;
    nightingaleSpinStopping = true;
    nightingaleStopClickCount = 0;
    nightingaleSpinStopAngle = Math.floor(nightingaleRotation / RADIAL_TAU) * RADIAL_TAU;
    if (nightingaleSpinStopAngle >= nightingaleRotation - 0.0005) {
      nightingaleSpinStopAngle -= RADIAL_TAU;
    }
  }

  function drawNightingale(w, h) {
    updateNightingaleSpin();

    const cx = w / 2;
    const cy = h / 2;
    const baseHue = (Date.now() / 60) % 360;
    const petals = 12;
    const innerRadius = 0;
    const maxRadius = Math.max(0, Math.min(cx, cy) - Math.max(8, Math.min(w, h) * 0.04));
    const angleInset = (RADIAL_TAU / petals) * 0.08;
    const overallLevel = getLevel();

    if (!nightingaleOuterSmoothed || nightingaleOuterSmoothed.length !== petals) {
      nightingaleOuterSmoothed = new Float32Array(petals);
      nightingaleInnerSmoothed = new Float32Array(petals);
      nightingaleLagBuffer = new Float32Array(petals);
      for (let i = 0; i < petals; i++) {
        const t = petals <= 1 ? 0 : i / (petals - 1);
        const outerInit = sampleFreq(t, 0.8, 0.9);
        const innerInit = sampleFreq((t + 0.16) % 1, 0.86, 0.88);
        nightingaleOuterSmoothed[i] = outerInit;
        nightingaleInnerSmoothed[i] = innerInit * 0.65;
        nightingaleLagBuffer[i] = outerInit;
      }
    } else {
      for (let i = 0; i < petals; i++) {
        const t = petals <= 1 ? 0 : i / (petals - 1);
        const outerTarget = sampleFreq(t, 0.8, 0.9);
        const innerBandTarget = sampleFreq((t + 0.16) % 1, 0.86, 0.88);
        const delayedOuter = nightingaleLagBuffer[i];

        nightingaleOuterSmoothed[i] += (outerTarget - nightingaleOuterSmoothed[i]) * NIGHTINGALE_OUTER_SMOOTHING;
        const innerTarget = Math.min(1, innerBandTarget * 0.62 + delayedOuter * 0.38);
        nightingaleInnerSmoothed[i] += (innerTarget - nightingaleInnerSmoothed[i]) * NIGHTINGALE_INNER_SMOOTHING;
        nightingaleLagBuffer[i] = nightingaleOuterSmoothed[i];
      }
    }

    // In true silence, collapse values quickly so petals disappear entirely.
    if (overallLevel < 0.004) {
      for (let i = 0; i < petals; i++) {
        nightingaleOuterSmoothed[i] *= 0.76;
        nightingaleInnerSmoothed[i] *= 0.72;
        nightingaleLagBuffer[i] *= 0.76;
        if (nightingaleOuterSmoothed[i] < 0.001) nightingaleOuterSmoothed[i] = 0;
        if (nightingaleInnerSmoothed[i] < 0.001) nightingaleInnerSmoothed[i] = 0;
        if (nightingaleLagBuffer[i] < 0.001) nightingaleLagBuffer[i] = 0;
      }
    }

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(nightingaleRotation);

    for (let i = 0; i < petals; i++) {
      const val = nightingaleOuterSmoothed[i];
      const innerVal = nightingaleInnerSmoothed[i];
      const start = (i / petals) * RADIAL_TAU - Math.PI / 2 + angleInset;
      const end = ((i + 1) / petals) * RADIAL_TAU - Math.PI / 2 - angleInset;
      const outerRadius = innerRadius + val * (maxRadius - innerRadius);
      const overlayBaseRadius = innerRadius + innerVal * (maxRadius - innerRadius) * 0.72;
      const overlayRadius = Math.min(outerRadius * 0.86, overlayBaseRadius);
      const hue = (baseHue + i * 10) % 360;
      const lightness = lightMode ? 42 : 60;
      if (outerRadius <= 0.35 && overlayRadius <= 0.28) continue;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, outerRadius, start, end);
      ctx.closePath();
      ctx.fillStyle = hslColor(hue, 64, lightness, 0.24 + val * 0.62);
      ctx.fill();

      // Overlay a shorter segment to mimic a classic rose-chart layering.
      if (overlayRadius > 0.25) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, overlayRadius, start, end);
        ctx.closePath();
        ctx.fillStyle = hslColor((hue + 10) % 360, 52, lightMode ? 34 : 68, 0.2 + val * 0.48);
        ctx.fill();
      }
    }

    ctx.restore();
  }

  // ═══════════════════════════════
  //  VISUALISER 6: Spectrum
  // ═══════════════════════════════
  let spectrumRotation = 0;
  let spectrumSpinSpeed = 0;
  let spectrumSpinEnabled = false;
  let spectrumSpinStopping = false;
  let spectrumSpinStopAngle = null;
  let spectrumStopClickCount = 0;
  let spectrumLastUpdate = performance.now();

  function updateSpectrumSpin() {
    const now = performance.now();
    const dt = Math.min(0.05, Math.max(0.001, (now - spectrumLastUpdate) / 1000));
    spectrumLastUpdate = now;

    if (spectrumSpinStopping && spectrumSpinStopAngle !== null) {
      const remaining = Math.max(0, spectrumRotation - spectrumSpinStopAngle);
      if (remaining <= 0.0005) {
        spectrumRotation = spectrumSpinStopAngle;
        spectrumSpinSpeed = 0;
        spectrumSpinEnabled = false;
        spectrumSpinStopping = false;
        spectrumSpinStopAngle = null;
        spectrumStopClickCount = 0;
        return;
      }

      const decelDistance = (RADIAL_SPIN_MAX_SPEED * RADIAL_SPIN_MAX_SPEED) / (2 * RADIAL_SPIN_DECEL);
      const desiredSpeed = remaining > decelDistance
        ? RADIAL_SPIN_MAX_SPEED
        : Math.sqrt(2 * RADIAL_SPIN_DECEL * remaining);

      if (spectrumSpinSpeed < desiredSpeed) {
        spectrumSpinSpeed = Math.min(desiredSpeed, spectrumSpinSpeed + RADIAL_SPIN_ACCEL * dt);
      } else if (spectrumSpinSpeed > desiredSpeed) {
        spectrumSpinSpeed = Math.max(desiredSpeed, spectrumSpinSpeed - RADIAL_SPIN_DECEL * dt);
      }

      spectrumRotation -= spectrumSpinSpeed * dt;
      if (spectrumRotation <= spectrumSpinStopAngle + 0.0005) {
        spectrumRotation = spectrumSpinStopAngle;
        spectrumSpinSpeed = 0;
        spectrumSpinEnabled = false;
        spectrumSpinStopping = false;
        spectrumSpinStopAngle = null;
        spectrumStopClickCount = 0;
      }
      return;
    }

    const desiredSpeed = spectrumSpinEnabled ? RADIAL_SPIN_MAX_SPEED : 0;
    if (spectrumSpinSpeed < desiredSpeed) {
      spectrumSpinSpeed = Math.min(desiredSpeed, spectrumSpinSpeed + RADIAL_SPIN_ACCEL * dt);
    } else if (spectrumSpinSpeed > desiredSpeed) {
      spectrumSpinSpeed = Math.max(desiredSpeed, spectrumSpinSpeed - RADIAL_SPIN_DECEL * dt);
    }

    if (spectrumSpinSpeed > 0.0001) {
      spectrumRotation -= spectrumSpinSpeed * dt;
    }
  }

  function toggleSpectrumSpin() {
    spectrumLastUpdate = performance.now();
    if (!spectrumSpinEnabled && !spectrumSpinStopping && spectrumSpinSpeed <= 0.001) {
      spectrumSpinEnabled = true;
      spectrumStopClickCount = 0;
      return;
    }
    if (spectrumSpinStopping) {
      spectrumStopClickCount++;
      if (spectrumStopClickCount >= RADIAL_STOP_SNAP_CLICKS) {
        const snapAngle = spectrumSpinStopAngle !== null
          ? spectrumSpinStopAngle
          : Math.floor(spectrumRotation / RADIAL_TAU) * RADIAL_TAU;
        spectrumRotation = snapAngle;
        spectrumSpinSpeed = 0;
        spectrumSpinEnabled = false;
        spectrumSpinStopping = false;
        spectrumSpinStopAngle = null;
        spectrumStopClickCount = 0;
      }
      return;
    }

    spectrumSpinEnabled = false;
    spectrumSpinStopping = true;
    spectrumStopClickCount = 0;
    spectrumSpinStopAngle = Math.floor(spectrumRotation / RADIAL_TAU) * RADIAL_TAU;
    if (spectrumSpinStopAngle >= spectrumRotation - 0.0005) {
      spectrumSpinStopAngle -= RADIAL_TAU;
    }
  }

  function drawSpectrumRing(w, h) {
    updateSpectrumSpin();

    const cx = w / 2;
    const cy = h / 2;
    const baseRadius = Math.min(w, h) * 0.2;
    const rings = 5;
    const baseHue = (Date.now() / 70) % 360;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(spectrumRotation);

    for (let r = 0; r < rings; r++) {
      const ringRadius = baseRadius + r * 30;
      const points = 128;

      ctx.beginPath();
      for (let i = 0; i <= points; i++) {
        const angle = (i / points) * RADIAL_TAU - Math.PI / 2;
        const t = (i % points) / (points - 1);
        const val = sampleFreq(t, 0.8, 0.88);
        const rad = ringRadius + val * 50 * (1 - r * 0.15);

        const x = Math.cos(angle) * rad;
        const y = Math.sin(angle) * rad;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();

      const hue = (baseHue + r * 30) % 360;
      const lightness = lightMode ? 40 : 60;
      ctx.strokeStyle = hslColor(hue, 60, lightness, 0.5 - r * 0.08);
      ctx.lineWidth = 2 - r * 0.2;
      ctx.stroke();
    }

    ctx.restore();
  }

  // ═══════════════════════════════
  //  VISUALISER 7: Terrain
  // ═══════════════════════════════
  function drawTerrain(w, h) {
    terrainFrameCount++;
    // Only push a new row every 3rd frame
    if (terrainFrameCount % 3 === 0) {
      const snapshot = [];
      const points = 100;
      for (let i = 0; i < points; i++) {
        const t = points <= 1 ? 0 : i / (points - 1);
        snapshot.push(sampleFreq(t, 0.82, 0.88));
      }
      terrainHistory.unshift(snapshot);
      if (terrainHistory.length > TERRAIN_ROWS) terrainHistory.pop();
    }

    const baseHue = (Date.now() / 80) % 360;
    const rowH = h / (TERRAIN_ROWS + 5);

    for (let r = terrainHistory.length - 1; r >= 0; r--) {
      const row = terrainHistory[r];
      const y0 = h * 0.3 + r * rowH;
      const fade = 1 - r / TERRAIN_ROWS;

      ctx.beginPath();
      for (let i = 0; i <= row.length; i++) {
        const x = (i / row.length) * w;
        const val = row[Math.min(i, row.length - 1)];
        const y = y0 - val * h * 0.15 * fade;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }

      const hue = (baseHue + r * 3) % 360;
      const lightness = lightMode ? 40 : 55;
      ctx.strokeStyle = hslColor(hue, 50, lightness, fade * 0.6);
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 8: Starfield
  // ═══════════════════════════════
  function drawStarfield(w, h) {
    updateStarfieldOrigin(w, h);
    const cx = starfieldOriginX;
    const cy = starfieldOriginY;
    const level = getLevel();
    const speed = 0.002 + level * 0.06;
    const baseHue = (Date.now() / 70) % 360;

    for (const star of stars) {
      star.z -= speed;
      if (star.z <= 0.001) {
        star.x = (Math.random() - 0.5) * 2;
        star.y = (Math.random() - 0.5) * 2;
        star.z = 1;
      }

      const sx = cx + (star.x / star.z) * cx;
      const sy = cy + (star.y / star.z) * cy;
      const size = (1 - star.z) * (2.5 + level * 8);
      const alpha = (1 - star.z);
      const hue = (baseHue + (1 - star.z) * 120) % 360;
      const lightness = lightMode ? 35 : 70;

      if (sx >= 0 && sx <= w && sy >= 0 && sy <= h) {
        ctx.beginPath();
        ctx.arc(sx, sy, Math.max(0.5, size), 0, Math.PI * 2);
        ctx.fillStyle = hslColor(hue, 60, lightness, alpha * 0.9);
        ctx.fill();

        // Trail
        const prevZ = star.z + speed;
        const psx = cx + (star.x / prevZ) * cx;
        const psy = cy + (star.y / prevZ) * cy;
        ctx.beginPath();
        ctx.moveTo(psx, psy);
        ctx.lineTo(sx, sy);
        ctx.strokeStyle = hslColor(hue, 60, lightness, alpha * 0.3);
        ctx.lineWidth = Math.max(0.3, size * 0.5);
        ctx.stroke();
      }
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 9: Aurora
  // ═══════════════════════════════
  let auroraTime = 0;
  function drawAurora(w, h) {
    auroraTime += 0.01;
    const level = getLevel();
    const baseHue = (Date.now() / 80) % 360;
    const bands = 6;
    const pointerStrength = pointerField.strength;
    const pointerY = pointerField.y;
    const pointerBandRadiusY = Math.max(60, h * 0.11);

    for (let b = 0; b < bands; b++) {
      const bandY = h * (0.2 + b * 0.12);
      const hue = (baseHue + b * 45) % 360;
      const lightness = lightMode ? 45 : 55;
      const alpha = 0.15 + level * 0.25;
      const bandHover = pointerStrength > 0.001
        ? Math.max(0, 1 - Math.abs(bandY - pointerY) / pointerBandRadiusY) * pointerStrength
        : 0;
      const dipOffset = bandHover * Math.max(12, h * 0.03);
      const bandAlpha = alpha * (1 - bandHover * 0.75);

      ctx.beginPath();
      ctx.moveTo(0, bandY);

      const points = 120;
      for (let i = 0; i <= points; i++) {
        const x = (i / points) * w;
        const freqIdx = Math.floor((i / points) * freqArray.length * 0.5);
        const freqVal = freqArray[freqIdx] / 255;
        const wave1 = Math.sin(auroraTime * 2 + i * 0.05 + b * 1.2) * 30;
        const wave2 = Math.sin(auroraTime * 1.3 + i * 0.03 + b * 0.8) * 20;
        const audioDisplace = freqVal * h * 0.08;
        let displacement = wave1 + wave2 - audioDisplace;
        if (bandHover > 0.001) displacement *= 1 - bandHover * 0.98;
        const y = bandY + dipOffset + displacement;
        ctx.lineTo(x, y);
      }

      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();

      const grad = ctx.createLinearGradient(0, bandY - 60, 0, bandY + 100);
      grad.addColorStop(0, hslColor(hue, 70, lightness, 0));
      grad.addColorStop(0.3, hslColor(hue, 70, lightness, bandAlpha * 0.7));
      grad.addColorStop(0.6, hslColor((hue + 30) % 360, 60, lightness, bandAlpha * 0.4));
      grad.addColorStop(1, hslColor(hue, 70, lightness, 0));
      ctx.fillStyle = grad;
      ctx.fill();
    }

    // Shimmer particles
    const shimmerCount = Math.floor(level * 15) + 3;
    for (let i = 0; i < shimmerCount; i++) {
      const sx = Math.random() * w;
      const sy = h * 0.15 + Math.random() * h * 0.6;
      const size = Math.random() * 2 + 0.5;
      const salpha = Math.random() * 0.4 * level;
      const shue = (baseHue + Math.random() * 90) % 360;
      ctx.beginPath();
      ctx.arc(sx, sy, size, 0, Math.PI * 2);
      ctx.fillStyle = hslColor(shue, 60, lightMode ? 50 : 70, salpha);
      ctx.fill();
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 10: Kaleidoscope
  // ═══════════════════════════════
  let kaleidoTime = 0;
  let kaleidoRotation = 0;
  let kaleidoSpinSpeed = 0;
  let kaleidoSpinEnabled = false;
  let kaleidoSpinStopping = false;
  let kaleidoSpinStopAngle = null;
  let kaleidoStopClickCount = 0;
  let kaleidoLastUpdate = performance.now();

  function updateKaleidoSpin() {
    const now = performance.now();
    const dt = Math.min(0.05, Math.max(0.001, (now - kaleidoLastUpdate) / 1000));
    kaleidoLastUpdate = now;

    if (kaleidoSpinStopping && kaleidoSpinStopAngle !== null) {
      const remaining = Math.max(0, kaleidoRotation - kaleidoSpinStopAngle);
      if (remaining <= 0.0005) {
        kaleidoRotation = kaleidoSpinStopAngle;
        kaleidoSpinSpeed = 0;
        kaleidoSpinEnabled = false;
        kaleidoSpinStopping = false;
        kaleidoSpinStopAngle = null;
        kaleidoStopClickCount = 0;
        return;
      }

      const decelDistance = (RADIAL_SPIN_MAX_SPEED * RADIAL_SPIN_MAX_SPEED) / (2 * RADIAL_SPIN_DECEL);
      const desiredSpeed = remaining > decelDistance
        ? RADIAL_SPIN_MAX_SPEED
        : Math.sqrt(2 * RADIAL_SPIN_DECEL * remaining);

      if (kaleidoSpinSpeed < desiredSpeed) {
        kaleidoSpinSpeed = Math.min(desiredSpeed, kaleidoSpinSpeed + RADIAL_SPIN_ACCEL * dt);
      } else if (kaleidoSpinSpeed > desiredSpeed) {
        kaleidoSpinSpeed = Math.max(desiredSpeed, kaleidoSpinSpeed - RADIAL_SPIN_DECEL * dt);
      }

      kaleidoRotation -= kaleidoSpinSpeed * dt;
      if (kaleidoRotation <= kaleidoSpinStopAngle + 0.0005) {
        kaleidoRotation = kaleidoSpinStopAngle;
        kaleidoSpinSpeed = 0;
        kaleidoSpinEnabled = false;
        kaleidoSpinStopping = false;
        kaleidoSpinStopAngle = null;
        kaleidoStopClickCount = 0;
      }
      return;
    }

    const desiredSpeed = kaleidoSpinEnabled ? RADIAL_SPIN_MAX_SPEED : 0;
    if (kaleidoSpinSpeed < desiredSpeed) {
      kaleidoSpinSpeed = Math.min(desiredSpeed, kaleidoSpinSpeed + RADIAL_SPIN_ACCEL * dt);
    } else if (kaleidoSpinSpeed > desiredSpeed) {
      kaleidoSpinSpeed = Math.max(desiredSpeed, kaleidoSpinSpeed - RADIAL_SPIN_DECEL * dt);
    }

    if (kaleidoSpinSpeed > 0.0001) {
      kaleidoRotation -= kaleidoSpinSpeed * dt;
    }
  }

  function toggleKaleidoSpin() {
    kaleidoLastUpdate = performance.now();
    if (!kaleidoSpinEnabled && !kaleidoSpinStopping && kaleidoSpinSpeed <= 0.001) {
      kaleidoSpinEnabled = true;
      kaleidoStopClickCount = 0;
      return;
    }
    if (kaleidoSpinStopping) {
      kaleidoStopClickCount++;
      if (kaleidoStopClickCount >= RADIAL_STOP_SNAP_CLICKS) {
        const snapAngle = kaleidoSpinStopAngle !== null
          ? kaleidoSpinStopAngle
          : Math.floor(kaleidoRotation / RADIAL_TAU) * RADIAL_TAU;
        kaleidoRotation = snapAngle;
        kaleidoSpinSpeed = 0;
        kaleidoSpinEnabled = false;
        kaleidoSpinStopping = false;
        kaleidoSpinStopAngle = null;
        kaleidoStopClickCount = 0;
      }
      return;
    }

    kaleidoSpinEnabled = false;
    kaleidoSpinStopping = true;
    kaleidoStopClickCount = 0;
    kaleidoSpinStopAngle = Math.floor(kaleidoRotation / RADIAL_TAU) * RADIAL_TAU;
    if (kaleidoSpinStopAngle >= kaleidoRotation - 0.0005) {
      kaleidoSpinStopAngle -= RADIAL_TAU;
    }
  }

  function drawKaleidoscope(w, h) {
    updateKaleidoSpin();
    kaleidoTime += 0.008;
    const cx = w / 2;
    const cy = h / 2;
    const level = getLevel();
    const baseHue = (Date.now() / 100) % 360;
    const segments = 12;
    const angleStep = (Math.PI * 2) / segments;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(kaleidoRotation);

    for (let s = 0; s < segments; s++) {
      ctx.save();
      ctx.rotate(s * angleStep);
      if (s % 2 === 1) ctx.scale(1, -1);

      const numShapes = 8;
      for (let i = 0; i < numShapes; i++) {
        const freqIdx = Math.floor((i / numShapes) * freqArray.length * 0.4);
        const val = freqArray[freqIdx] / 255;
        const dist = 40 + i * 35 + val * 60;
        const size = 8 + val * 30;
        const hue = (baseHue + i * 25 + s * 5) % 360;
        const lightness = lightMode ? 45 : 58;
        const alpha = 0.3 + val * 0.4;

        const px = Math.cos(kaleidoTime + i * 0.5) * dist;
        const py = Math.sin(kaleidoTime * 0.7 + i * 0.3) * dist * 0.5;

        ctx.beginPath();
        ctx.arc(px, py, size, 0, Math.PI * 2);
        ctx.fillStyle = hslColor(hue, 65, lightness, alpha);
        ctx.fill();
      }
      ctx.restore();
    }
    ctx.restore();
  }

  // ═══════════════════════════════
  //  VISUALISER 11: Raindrops
  // ═══════════════════════════════
  let raindrops = [];
  const MAX_RAINDROPS = 40;
  function getCanvasPoint(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  }
  function spawnRaindropBurst(x, y, intensity = 0.8, countOverride = null) {
    const clamped = Math.max(0, Math.min(1, intensity));
    const baseHue = (Date.now() / 90) % 360;
    const count = countOverride === null ? 3 + Math.floor(clamped * 4) : Math.max(1, Math.floor(countOverride));
    for (let i = 0; i < count; i++) {
      if (raindrops.length >= MAX_RAINDROPS) raindrops.shift();
      raindrops.push({
        x: x + (Math.random() - 0.5) * 28,
        y: y + (Math.random() - 0.5) * 28,
        radius: 0,
        maxRadius: 95 + Math.random() * 145 + clamped * 85,
        speed: 0.6 + Math.random() * 1.0,
        hue: (baseHue + Math.random() * 60) % 360,
        life: 1
      });
    }
  }
  function drawRaindrops(w, h) {
    const level = getLevel();
    const baseHue = (Date.now() / 90) % 360;

    // Spawn new drops based on audio
    const spawnCount = level > 0.05 ? Math.floor(level * 2) + 1 : 0;
    for (let i = 0; i < spawnCount && raindrops.length < MAX_RAINDROPS; i++) {
      raindrops.push({
        x: Math.random() * w,
        y: Math.random() * h,
        radius: 0,
        maxRadius: 60 + Math.random() * 120 + level * 80,
        speed: 0.3 + Math.random() * 0.6,
        hue: (baseHue + Math.random() * 60) % 360,
        life: 1
      });
    }

    // Update & draw
    raindrops = raindrops.filter(d => d.life > 0);
    for (const d of raindrops) {
      d.radius += d.speed;
      d.life = 1 - (d.radius / d.maxRadius);
      if (d.life <= 0) continue;

      const lightness = lightMode ? 40 : 60;

      // Multiple expanding rings per drop
      for (let r = 0; r < 3; r++) {
        const ringRadius = d.radius * (1 - r * 0.25);
        if (ringRadius <= 0) continue;
        const ringAlpha = d.life * (0.5 - r * 0.15);
        ctx.beginPath();
        ctx.arc(d.x, d.y, ringRadius, 0, Math.PI * 2);
        ctx.strokeStyle = hslColor(d.hue, 50, lightness, ringAlpha);
        ctx.lineWidth = 1.5 - r * 0.3;
        ctx.stroke();
      }
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 12: Swirls
  // ═══════════════════════════════
  let swirlTime = 0;
  let swirlDirection = 1;
  function drawSwirls(w, h) {
    swirlTime += 0.006 * swirlDirection;
    const cx = w / 2;
    const cy = h / 2;
    const level = getLevel();
    const baseHue = (Date.now() / 70) % 360;
    const numSwirls = 5;
    const pointsPerSwirl = 200;

    for (let s = 0; s < numSwirls; s++) {
      const hue = (baseHue + s * 55) % 360;
      const lightness = lightMode ? 40 : 60;
      const swirlOffset = s * (Math.PI * 2 / numSwirls);

      ctx.beginPath();
      for (let i = 0; i < pointsPerSwirl; i++) {
        const t = i / pointsPerSwirl;
        const freqIdx = Math.floor(t * freqArray.length * 0.5);
        const val = freqArray[freqIdx] / 255;
        const angle = swirlOffset + t * Math.PI * 6 + swirlTime * (2 + s * 0.3);
        const dist = t * Math.min(w, h) * 0.45 + val * 40;
        const wobble = Math.sin(swirlTime * 3 + t * 10 + s) * (10 + val * 20);

        const x = cx + Math.cos(angle) * (dist + wobble);
        const y = cy + Math.sin(angle) * (dist + wobble);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }

      const alpha = 0.25 + level * 0.35;
      ctx.strokeStyle = hslColor(hue, 60, lightness, alpha);
      ctx.lineWidth = 1.5 + level * 2;
      ctx.stroke();
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 13: Fog
  // ═══════════════════════════════
  let fogCircles = [];
  let fogCirclesW = 0;
  let fogCirclesH = 0;

  function initFogCircles(w, h) {
    const area = w * h;
    const count = Math.max(24, Math.min(56, Math.round(area / 42000)));
    const baseSize = Math.min(w, h);

    fogCircles = Array.from({ length: count }, () => ({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.22,
      vy: (Math.random() - 0.5) * 0.22,
      driftPhase: Math.random() * RADIAL_TAU,
      pulsePhase: Math.random() * RADIAL_TAU,
      pulseSpeed: 0.004 + Math.random() * 0.009,
      baseRadius: baseSize * (0.025 + Math.random() * 0.055),
      hueOffset: Math.random() * 120,
      freqT: Math.random() * 0.95
    }));
    fogCirclesW = w;
    fogCirclesH = h;
  }

  function ensureFogCircles(w, h) {
    if (!fogCircles.length) {
      initFogCircles(w, h);
      return;
    }
    if (Math.abs(w - fogCirclesW) > 48 || Math.abs(h - fogCirclesH) > 48) {
      initFogCircles(w, h);
    }
  }

  function drawDancingCircles(w, h) {
    ensureFogCircles(w, h);

    const level = getLevel();
    const baseHue = (Date.now() / 90) % 360;
    const lightness = lightMode ? 46 : 60;
    const pointerStrength = pointerField.strength;
    const repelRadius = Math.max(120, Math.min(w, h) * 0.24);

    for (const c of fogCircles) {
      const audioVal = sampleFreq(c.freqT, 0.82, 0.88);
      c.pulsePhase += c.pulseSpeed * (0.9 + level * 0.55);
      c.driftPhase += 0.003 + audioVal * 0.012;

      const pulse = Math.pow((Math.sin(c.pulsePhase) + 1) * 0.5, 1.65);
      const radius = c.baseRadius * pulse * (0.76 + audioVal * 0.34);
      if (radius < 0.75) continue;

      c.x += c.vx + Math.cos(c.driftPhase) * 0.05 + (audioVal - 0.4) * 0.08;
      c.y += c.vy + Math.sin(c.driftPhase * 0.9) * 0.05;

      if (pointerStrength > 0.001) {
        const dx = c.x - pointerField.x;
        const dy = c.y - pointerField.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 0.0001 && dist < repelRadius) {
          const falloff = 1 - dist / repelRadius;
          const push = falloff * falloff * pointerStrength * (0.66 + audioVal * 0.56);
          c.x += (dx / dist) * push;
          c.y += (dy / dist) * push;
        }
      }

      const wrap = radius * 1.35 + 18;
      if (c.x < -wrap) c.x = w + wrap;
      else if (c.x > w + wrap) c.x = -wrap;
      if (c.y < -wrap) c.y = h + wrap;
      else if (c.y > h + wrap) c.y = -wrap;

      const hue = (baseHue + c.hueOffset + audioVal * 40) % 360;
      const alpha = (0.04 + pulse * 0.25) * (0.78 + audioVal * 0.5);

      const grad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, radius);
      grad.addColorStop(0, hslColor(hue, 56, lightness, alpha));
      grad.addColorStop(0.68, hslColor(hue, 52, lightness, alpha * 0.46));
      grad.addColorStop(1, hslColor(hue, 50, lightness, 0));
      ctx.beginPath();
      ctx.arc(c.x, c.y, radius, 0, RADIAL_TAU);
      ctx.fillStyle = grad;
      ctx.fill();
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 14: Fireworks
  // ═══════════════════════════════
  let fireworkParticles = [];
  let fwCooldown = 0;
  const MAX_FW_PARTICLES = 300;
  const FIREWORK_TRAIL_LENGTH_FACTOR = 1.2;
  function spawnFireworkBurst(burstX, burstY, intensity = 0.7) {
    const clamped = Math.max(0, Math.min(1, intensity));
    const room = MAX_FW_PARTICLES - fireworkParticles.length;
    if (room <= 0) return;

    const baseHue = (Date.now() / 120) % 360;
    const burstHue = (baseHue + Math.random() * 120) % 360;
    const count = Math.min(room, 12 + Math.floor(clamped * 18));

    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2 + Math.random() * 0.2;
      const speed = 0.4 + Math.random() * 1.0 + clamped * 1.2;
      fireworkParticles.push({
        x: burstX,
        y: burstY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        decay: (0.002 + Math.random() * 0.005) / FIREWORK_TRAIL_LENGTH_FACTOR,
        size: 1.5 + Math.random() * 2,
        hue: (burstHue + Math.random() * 30) % 360,
        gravity: 0.005 + Math.random() * 0.008
      });
    }
  }
  function drawFireworks(w, h) {
    // Fade toward the mode background and aggressively clean low-activity residue.
    const activeFactor = Math.min(1, fireworkParticles.length / 120);
    const idleFactor = Math.min(1, Math.max(0, 1 - fireworkParticles.length / 18));
    const fadeAlpha = Math.min(0.3, 0.1 + (1 - activeFactor) * 0.1 + idleFactor * 0.08);
    ctx.fillStyle = lightMode
      ? `rgba(245,245,245,${fadeAlpha})`
      : `rgba(0,0,0,${fadeAlpha})`;
    ctx.fillRect(0, 0, w, h);

    const level = getLevel();
    fwCooldown--;

    // Launch fireworks gently
    if (level > 0.03 && fwCooldown <= 0 && fireworkParticles.length < MAX_FW_PARTICLES - 30) {
      const burstX = w * 0.2 + Math.random() * w * 0.6;
      const burstY = h * 0.15 + Math.random() * h * 0.4;
      spawnFireworkBurst(burstX, burstY, level);
      fwCooldown = 30 + Math.floor(Math.random() * 40);
    }

    // Update & draw particles
    fireworkParticles = fireworkParticles.filter(p => p.life > 0);
    for (const p of fireworkParticles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += p.gravity;
      p.vx *= 0.995;
      p.vy *= 0.995;
      p.life -= p.decay;

      const lightness = lightMode ? 45 : 65;
      const alpha = p.life * 0.7;

      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fillStyle = hslColor(p.hue, 65, lightness, alpha);
      ctx.fill();
    }
  }

  // ═══════════════════════════════
  //  VISUALISER 15: Polygraph
  // ═══════════════════════════════
  let polyHistory = [];
  let polygraphShowBackground = false;
  const POLY_MAX_POINTS = 800;
  function drawPolygraph(w, h) {
    const level = getLevel();

    // Compute RMS for speech amplitude
    let rms = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = (dataArray[i] / 128) - 1;
      rms += v * v;
    }
    rms = Math.sqrt(rms / dataArray.length);

    polyHistory.push(rms);
    if (polyHistory.length > POLY_MAX_POINTS) polyHistory.shift();

    const baseHue = (Date.now() / 100) % 360;
    const lightness = lightMode ? 30 : 70;
    const graphX = 0;
    const graphW = w;
    const graphH = h * 0.6;
    const graphY = h * 0.2;

    if (polygraphShowBackground) {
      // Grid lines
      ctx.strokeStyle = fg(0.06);
      ctx.lineWidth = 1;
      for (let i = 0; i <= 8; i++) {
        const y = graphY + (i / 8) * graphH;
        ctx.beginPath();
        ctx.moveTo(graphX, y);
        ctx.lineTo(graphX + graphW, y);
        ctx.stroke();
      }
      for (let i = 0; i <= 10; i++) {
        const x = graphX + (i / 10) * graphW;
        ctx.beginPath();
        ctx.moveTo(x, graphY);
        ctx.lineTo(x, graphY + graphH);
        ctx.stroke();
      }
    }

    // Draw the polygraph line
    if (polyHistory.length > 1) {
      ctx.beginPath();
      for (let i = 0; i < polyHistory.length; i++) {
        const x = graphX + (i / POLY_MAX_POINTS) * graphW;
        const val = Math.min(polyHistory[i] * 3, 1);
        const y = graphY + graphH - val * graphH;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = hslColor(baseHue, 50, lightness, 0.8);
      ctx.lineWidth = 2;
      ctx.stroke();

      // Filled signal area reaches full window unless graph UI is enabled.
      const lastX = graphX + ((polyHistory.length - 1) / POLY_MAX_POINTS) * graphW;
      const fillBottom = polygraphShowBackground ? (graphY + graphH) : h;
      ctx.lineTo(lastX, fillBottom);
      ctx.lineTo(graphX, fillBottom);
      ctx.closePath();
      ctx.fillStyle = hslColor(baseHue, 50, lightness, polygraphShowBackground ? 0.06 : 0.035);
      ctx.fill();
    }

    // Current level indicator on right
    const curVal = Math.min(rms * 3, 1);
    const indicatorY = graphY + graphH - curVal * graphH;
    const indicatorX = Math.min(graphX + graphW, graphX + (polyHistory.length / POLY_MAX_POINTS) * graphW);
    ctx.beginPath();
    ctx.arc(indicatorX, indicatorY, 4 + level * 4, 0, Math.PI * 2);
    ctx.fillStyle = hslColor(baseHue, 60, lightness, 0.9);
    ctx.fill();
  }

  // ═══════════════════════════════
  //  VISUALISER 16: Decibels
  // ═══════════════════════════════
  let dbHistory = [];
  const DB_MAX_POINTS = 200;
  const DB_HISTORY_PUSH_INTERVAL = 2;
  let dbHistoryFrame = 0;
  let peakDb = -100;
  let peakHold = 0;
  let decibelsShowChart = false;
  function drawDecibels(w, h) {
    // Calculate dB from RMS
    let rms = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = (dataArray[i] / 128) - 1;
      rms += v * v;
    }
    rms = Math.sqrt(rms / dataArray.length);
    const db = rms > 0 ? 20 * Math.log10(rms) : -100;
    const clampedDb = Math.max(-60, Math.min(0, db));
    const normalized = (clampedDb + 60) / 60; // 0 to 1

    dbHistoryFrame++;
    if (dbHistoryFrame % DB_HISTORY_PUSH_INTERVAL === 0) {
      dbHistory.push(normalized);
      if (dbHistory.length > DB_MAX_POINTS) dbHistory.shift();
    }

    // Peak hold
    if (normalized > peakDb) {
      peakDb = normalized;
      peakHold = 60;
    }
    peakHold--;
    if (peakHold <= 0) peakDb *= 0.98;

    const margin = 60;
    const meterW = w - margin * 2;
    const meterH = 40;
    const meterY = h * 0.35;

    // Main meter background
    ctx.fillStyle = fg(0.04);
    ctx.beginPath();
    roundedRectPath(margin, meterY, meterW, meterH, 6);
    ctx.fill();

    // Meter fill with color gradient (green -> yellow -> red)
    if (normalized > 0) {
      const fillW = normalized * meterW;
      const grad = ctx.createLinearGradient(margin, 0, margin + meterW, 0);
      const gL = lightMode ? 35 : 50;
      grad.addColorStop(0, hslColor(120, 60, gL, 0.8));
      grad.addColorStop(0.6, hslColor(60, 70, gL, 0.8));
      grad.addColorStop(0.85, hslColor(30, 75, gL, 0.8));
      grad.addColorStop(1, hslColor(0, 80, gL, 0.9));
      ctx.fillStyle = grad;
      ctx.beginPath();
      roundedRectPath(margin, meterY, fillW, meterH, 6);
      ctx.fill();
    }

    // Peak hold marker
    const peakX = margin + peakDb * meterW;
    ctx.fillStyle = fg(0.6);
    ctx.fillRect(peakX - 1, meterY - 2, 2, meterH + 4);

    const graphY = h * 0.55;
    const graphH = h * 0.3;

    if (decibelsShowChart) {
      // Scale markings
      ctx.fillStyle = fg(0.2);
      for (let db = -60; db <= 0; db += 10) {
        const x = margin + ((db + 60) / 60) * meterW;
        ctx.fillRect(x, meterY + meterH + 4, 1, 6);
      }

      // Grid
      ctx.strokeStyle = fg(0.04);
      ctx.lineWidth = 1;
      for (let i = 0; i <= 6; i++) {
        const y = graphY + (i / 6) * graphH;
        ctx.beginPath();
        ctx.moveTo(margin, y);
        ctx.lineTo(w - margin, y);
        ctx.stroke();
      }

    }

    // Always show the colored history line; chart toggle controls only UI/grid.
    if (dbHistory.length > 1) {
      ctx.beginPath();
      for (let i = 0; i < dbHistory.length; i++) {
        const x = margin + (i / DB_MAX_POINTS) * meterW;
        const y = graphY + graphH - dbHistory[i] * graphH;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      const lightness = lightMode ? 35 : 55;
      ctx.strokeStyle = hslColor(120, 40, lightness, 0.5);
      ctx.lineWidth = 1.5;
      ctx.stroke();

      if (decibelsShowChart) {
        // Filled area under the line belongs to chart UI.
        const lastX = margin + ((dbHistory.length - 1) / DB_MAX_POINTS) * meterW;
        ctx.lineTo(lastX, graphY + graphH);
        ctx.lineTo(margin, graphY + graphH);
        ctx.closePath();
        ctx.fillStyle = hslColor(120, 40, lightness, 0.04);
        ctx.fill();
      }
    }
  }

  // ── Visualiser Picker ──
  const visPicker = document.getElementById('visPicker');
  const visPickerGrid = document.getElementById('visPickerGrid');

  function showVisPicker() {
    visPickerGrid.innerHTML = '';
    // Random button (large, spans full width)
    const randBtn = document.createElement('button');
    randBtn.className = 'pick-item pick-random';
    randBtn.textContent = 'random';
    randBtn.addEventListener('click', () => {
      currentVis = Math.floor(Math.random() * visualisers.length);
      resetVisState();
      startVisualiser();
    });
    visPickerGrid.appendChild(randBtn);

    // Individual visualisers
    visualisers.forEach((v, i) => {
      const btn = document.createElement('button');
      btn.className = 'pick-item';
      btn.textContent = v.name;
      btn.addEventListener('click', () => {
        currentVis = i;
        resetVisState();
        startVisualiser();
      });
      visPickerGrid.appendChild(btn);
    });
    visPicker.classList.remove('hidden');
  }

  function startVisualiser() {
    visPicker.classList.add('hidden');
    if (!running) { running = true; resize(); animate(); }
    requestWakeLock();
  }

  // ── UI Logic ──
  const dialogEl = document.getElementById('dialog');
  const sensitivityControl = document.getElementById('sensitivityControl');
  const sensitivityLabel = document.getElementById('sensitivityLabel');
  const sensitivitySlider = document.getElementById('sensitivitySlider');

  function setSensitivity(value = DEFAULT_SENSITIVITY) {
    const clamped = Math.min(SENSITIVITY_MAX, Math.max(SENSITIVITY_MIN, value));
    sensitivity = clamped;
    sensitivitySlider.value = String(sensitivityToSliderValue(clamped));
  }

  function clamp01(v) {
    return Math.min(1, Math.max(0, v));
  }

  function sliderValueToSensitivity(value) {
    const t = clamp01(value);
    if (t <= 0.5) {
      const lowSpan = DEFAULT_SENSITIVITY - SENSITIVITY_MIN;
      return SENSITIVITY_MIN + (t / 0.5) * lowSpan;
    }
    const highSpan = SENSITIVITY_MAX - DEFAULT_SENSITIVITY;
    return DEFAULT_SENSITIVITY + ((t - 0.5) / 0.5) * highSpan;
  }

  function sensitivityToSliderValue(value) {
    const clamped = Math.min(SENSITIVITY_MAX, Math.max(SENSITIVITY_MIN, value));
    if (clamped <= DEFAULT_SENSITIVITY) {
      const lowSpan = DEFAULT_SENSITIVITY - SENSITIVITY_MIN;
      return lowSpan > 0 ? ((clamped - SENSITIVITY_MIN) / lowSpan) * 0.5 : SENSITIVITY_UI_DEFAULT;
    }
    const highSpan = SENSITIVITY_MAX - DEFAULT_SENSITIVITY;
    return highSpan > 0 ? 0.5 + ((clamped - DEFAULT_SENSITIVITY) / highSpan) * 0.5 : SENSITIVITY_UI_DEFAULT;
  }

  function setSensitivityAdjusting(active) {
    const shouldShowAdjusting = active && running && changingSource;
    dialogEl.classList.toggle('sensitivity-adjusting', shouldShowAdjusting);
  }

  function updateSensitivityControlVisibility() {
    const show = running && changingSource;
    sensitivityControl.classList.toggle('show', show);
    if (!show) setSensitivityAdjusting(false);
  }

  sensitivitySlider.addEventListener('input', () => {
    const next = Number.parseFloat(sensitivitySlider.value);
    const mapped = sliderValueToSensitivity(Number.isFinite(next) ? next : SENSITIVITY_UI_DEFAULT);
    setSensitivity(mapped);
  });
  sensitivitySlider.addEventListener('pointerdown', () => setSensitivityAdjusting(true));
  sensitivitySlider.addEventListener('pointerup', () => setSensitivityAdjusting(false));
  sensitivitySlider.addEventListener('pointercancel', () => setSensitivityAdjusting(false));
  sensitivitySlider.addEventListener('mousedown', () => setSensitivityAdjusting(true));
  sensitivitySlider.addEventListener('mouseup', () => setSensitivityAdjusting(false));
  sensitivitySlider.addEventListener('touchstart', () => setSensitivityAdjusting(true), { passive: true });
  sensitivitySlider.addEventListener('touchend', () => setSensitivityAdjusting(false), { passive: true });
  sensitivitySlider.addEventListener('touchcancel', () => setSensitivityAdjusting(false), { passive: true });
  sensitivitySlider.addEventListener('keydown', () => setSensitivityAdjusting(true));
  sensitivitySlider.addEventListener('keyup', () => setSensitivityAdjusting(false));
  sensitivitySlider.addEventListener('change', () => setSensitivityAdjusting(false));
  sensitivitySlider.addEventListener('blur', () => setSensitivityAdjusting(false));
  sensitivitySlider.addEventListener('dblclick', () => setSensitivity(DEFAULT_SENSITIVITY));
  window.addEventListener('pointerup', () => setSensitivityAdjusting(false));
  window.addEventListener('mouseup', () => setSensitivityAdjusting(false));
  window.addEventListener('touchend', () => setSensitivityAdjusting(false), { passive: true });
  window.addEventListener('touchcancel', () => setSensitivityAdjusting(false), { passive: true });
  sensitivityLabel.addEventListener('click', () => setSensitivity(DEFAULT_SENSITIVITY));
  sensitivityLabel.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      setSensitivity(DEFAULT_SENSITIVITY);
    }
  });
  setSensitivity(DEFAULT_SENSITIVITY);
  updateSensitivityControlVisibility();

  // Dialog buttons
  document.getElementById('btnMic').addEventListener('click', () => initAudio('mic'));
  document.getElementById('btnSystem').addEventListener('click', () => initAudio('system'));

  // Click outside source buttons dismisses dialog when changing source mid-session
  dialogEl.addEventListener('click', (e) => {
    if (e.target === dialogEl && changingSource && running) {
      changingSource = false;
      dialogEl.classList.add('hidden');
      updateSensitivityControlVisibility();
    }
  });

  // Options toggle
  const optBtn = document.getElementById('optBtn');
  const optPanel = document.getElementById('optPanel');
  const visNameHint = document.getElementById('visNameHint');
  const RADIAL_CLICK_EXCLUSION = 30;
  let visNameHintTimer = null;

  function showVisNameHint(text = visualisers[currentVis].name) {
    visNameHint.textContent = text;
    visNameHint.classList.add('show');
    clearTimeout(visNameHintTimer);
    visNameHintTimer = setTimeout(() => {
      visNameHint.classList.remove('show');
    }, 1000);
  }

  function isNearOptionsButton(x, y) {
    const rect = optBtn.getBoundingClientRect();
    return x >= rect.left - RADIAL_CLICK_EXCLUSION &&
      x <= rect.right + RADIAL_CLICK_EXCLUSION &&
      y >= rect.top - RADIAL_CLICK_EXCLUSION &&
      y <= rect.bottom + RADIAL_CLICK_EXCLUSION;
  }

  function canUseCanvasInteraction(x, y) {
    if (!running) return false;
    if (isNearOptionsButton(x, y)) return false;
    if (optPanel.classList.contains('open')) return false;
    if (!visPicker.classList.contains('hidden')) return false;
    if (!dialogEl.classList.contains('hidden')) return false;
    if (menuOverlay.classList.contains('open')) return false;
    if (colourOverlay.classList.contains('open')) return false;
    return true;
  }

  function setPointerFieldFromClient(clientX, clientY) {
    const p = getCanvasPoint(clientX, clientY);
    pointerField.x = p.x;
    pointerField.y = p.y;
  }

  function activatePointerField(clientX, clientY) {
    setPointerFieldFromClient(clientX, clientY);
    pointerField.active = true;
  }

  function clearPointerField(pointerId = null) {
    if (pointerId === null) {
      pointerField.touchPointerId = null;
      pointerField.active = false;
      return;
    }
    if (pointerId !== null && pointerField.touchPointerId !== pointerId) return;
    if (pointerId !== null && pointerField.touchPointerId === pointerId) {
      pointerField.touchPointerId = null;
    }
    pointerField.active = false;
  }

  const HOLD_SPAWN_INTERVAL_MS = 300;
  let holdSpawnTimer = null;
  let holdSpawnMode = null;
  let holdSpawnPointerId = null;
  let holdSpawnSuppressClick = false;
  const holdSpawnPoint = { x: 0, y: 0 };

  canvas.addEventListener('pointerdown', (e) => {
    if (!canUseCanvasInteraction(e.clientX, e.clientY)) return;
    activatePointerField(e.clientX, e.clientY);
    if (e.pointerType !== 'mouse') pointerField.touchPointerId = e.pointerId;

    const mode = visualisers[currentVis].name;
    if (mode !== 'starfield') return;

    if (e.pointerType === 'mouse') {
      if (e.button !== undefined && e.button !== 0) return;
      if (!starfieldMouseFollow) {
        setStarfieldOriginFromClient(e.clientX, e.clientY);
        starfieldMouseFollow = true;
      } else {
        starfieldMouseFollow = false;
        beginStarfieldReturn();
      }
      return;
    }

    starfieldMouseFollow = false;
    starfieldTouchDragging = true;
    starfieldTouchPointerId = e.pointerId;
    setStarfieldOriginFromClient(e.clientX, e.clientY);
    canvas.setPointerCapture?.(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    const mode = visualisers[currentVis].name;

    if (e.pointerType === 'mouse') {
      if (!canUseCanvasInteraction(e.clientX, e.clientY)) {
        pointerField.active = false;
        return;
      }
      activatePointerField(e.clientX, e.clientY);
      if (mode === 'starfield' && starfieldMouseFollow) {
        setStarfieldOriginFromClient(e.clientX, e.clientY);
      }
      return;
    }
    if (pointerField.touchPointerId !== e.pointerId) return;
    if (!canUseCanvasInteraction(e.clientX, e.clientY)) {
      clearPointerField(e.pointerId);
      return;
    }
    activatePointerField(e.clientX, e.clientY);

    if (mode === 'starfield' && starfieldTouchDragging && e.pointerId === starfieldTouchPointerId) {
      setStarfieldOriginFromClient(e.clientX, e.clientY);
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    const mode = visualisers[currentVis].name;
    if (e.pointerType !== 'mouse') {
      clearPointerField(e.pointerId);
      if (mode === 'starfield') {
        stopStarfieldTouchDrag(e.pointerId);
        canvas.releasePointerCapture?.(e.pointerId);
      }
    }
  });
  canvas.addEventListener('pointercancel', (e) => {
    clearPointerField(e.pointerId);
    stopStarfieldTouchDrag(e.pointerId);
    canvas.releasePointerCapture?.(e.pointerId);
  });
  canvas.addEventListener('pointerleave', (e) => {
    if (e.pointerType === 'mouse') {
      pointerField.active = false;
    } else {
      clearPointerField(e.pointerId);
      stopStarfieldTouchDrag(e.pointerId);
      canvas.releasePointerCapture?.(e.pointerId);
    }
  });
  window.addEventListener('blur', () => {
    clearPointerField();
    pointerField.strength = 0;
    starfieldMouseFollow = false;
    stopStarfieldTouchDrag();
    if (!starfieldReturnActive) beginStarfieldReturn();
  });

  function spawnModeAtPointer(mode, clientX, clientY) {
    const p = getCanvasPoint(clientX, clientY);
    if (mode === 'fireworks') {
      spawnFireworkBurst(p.x, p.y, 0.75);
    } else if (mode === 'raindrops') {
      spawnRaindropBurst(p.x, p.y, 1, 1);
    }
  }

  function stopHoldSpawn() {
    if (holdSpawnTimer) {
      clearInterval(holdSpawnTimer);
      holdSpawnTimer = null;
    }
    holdSpawnMode = null;
    holdSpawnPointerId = null;
  }

  canvas.addEventListener('pointerdown', (e) => {
    const mode = visualisers[currentVis].name;
    if (mode !== 'fireworks' && mode !== 'raindrops') return;
    if (!canUseCanvasInteraction(e.clientX, e.clientY)) return;
    if (e.button !== undefined && e.button !== 0) return;

    stopHoldSpawn();
    holdSpawnMode = mode;
    holdSpawnPointerId = e.pointerId;
    holdSpawnPoint.x = e.clientX;
    holdSpawnPoint.y = e.clientY;
    holdSpawnSuppressClick = false;

    holdSpawnTimer = setInterval(() => {
      if (!holdSpawnMode) return;
      if (!canUseCanvasInteraction(holdSpawnPoint.x, holdSpawnPoint.y)) return;
      spawnModeAtPointer(holdSpawnMode, holdSpawnPoint.x, holdSpawnPoint.y);
      holdSpawnSuppressClick = true;
    }, HOLD_SPAWN_INTERVAL_MS);

    canvas.setPointerCapture?.(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    if (holdSpawnPointerId === null || e.pointerId !== holdSpawnPointerId) return;
    holdSpawnPoint.x = e.clientX;
    holdSpawnPoint.y = e.clientY;
  });

  function endHoldSpawnForPointer(e) {
    if (holdSpawnPointerId === null || e.pointerId !== holdSpawnPointerId) return;
    stopHoldSpawn();
    canvas.releasePointerCapture?.(e.pointerId);
  }

  canvas.addEventListener('pointerup', endHoldSpawnForPointer);
  canvas.addEventListener('pointercancel', endHoldSpawnForPointer);
  window.addEventListener('blur', stopHoldSpawn);

  canvas.addEventListener('click', (e) => {
    if (!canUseCanvasInteraction(e.clientX, e.clientY)) return;

    const mode = visualisers[currentVis].name;
    if (mode === 'bars') {
      barsVariant = (barsVariant + 1) % BARS_VARIANT_COUNT;
    } else if (mode === 'waveform') {
      waveformVertical = !waveformVertical;
    } else if (mode === 'nightingale') {
      toggleNightingaleSpin();
    } else if (mode === 'radial') {
      toggleRadialSpin();
    } else if (mode === 'spectrum') {
      toggleSpectrumSpin();
    } else if (mode === 'kaleidoscope') {
      toggleKaleidoSpin();
    } else if (mode === 'polygraph') {
      polygraphShowBackground = !polygraphShowBackground;
    } else if (mode === 'decibels') {
      decibelsShowChart = !decibelsShowChart;
    } else if (mode === 'fireworks') {
      if (holdSpawnSuppressClick) {
        holdSpawnSuppressClick = false;
        return;
      }
      spawnModeAtPointer(mode, e.clientX, e.clientY);
    } else if (mode === 'raindrops') {
      if (holdSpawnSuppressClick) {
        holdSpawnSuppressClick = false;
        return;
      }
      spawnModeAtPointer(mode, e.clientX, e.clientY);
    } else if (mode === 'swirls') {
      swirlDirection *= -1;
    }
  });

  optBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const open = optPanel.classList.toggle('open');
    optBtn.classList.toggle('open', open);
  });

  document.addEventListener('click', () => {
    optPanel.classList.remove('open');
    optBtn.classList.remove('open');
  });
  optPanel.addEventListener('click', (e) => e.stopPropagation());

  // Fullscreen
  document.getElementById('optFullscreen').addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen?.() ||
      document.documentElement.webkitRequestFullscreen?.();
    } else {
      document.exitFullscreen?.() || document.webkitExitFullscreen?.();
    }
    closeOptions();
  });

  // Theme toggle
  const themeBtn = document.getElementById('optTheme');
  themeBtn.addEventListener('click', () => {
    lightMode = !lightMode;
    document.body.classList.toggle('light', lightMode);
    themeBtn.textContent = lightMode ? 'dark mode' : 'light mode';
    closeOptions();
  });

  // Next visualiser
  document.getElementById('optNext').addEventListener('click', () => {
    currentVis = (currentVis + 1) % visualisers.length;
    resetVisState();
    showVisNameHint();
  });

  // Menu button
  document.getElementById('optMenu').addEventListener('click', () => {
    openMenu();
    closeOptions();
  });

  // Change source
  document.getElementById('optSource').addEventListener('click', () => {
    changingSource = true;
    dialogEl.classList.remove('hidden');
    updateSensitivityControlVisibility();
    closeOptions();
  });

  // Share
  document.getElementById('optShare').addEventListener('click', () => {
    if (navigator.share) {
      navigator.share({ title: 'visualiser', url: window.location.href }).catch(() => {});
    } else {
      navigator.clipboard.writeText(window.location.href).then(() => {
        const btn = document.getElementById('optShare');
        btn.textContent = 'link copied';
        setTimeout(() => { btn.textContent = 'share'; }, 1500);
      });
    }
  });

  function closeOptions() {
    optPanel.classList.remove('open');
    optBtn.classList.remove('open');
  }

  // ── Colour Picker ──
  const colourGrid = document.getElementById('colourGrid');

  const colourOptions = [
    { id: 'rainbow', swatch: 'conic-gradient(#f88, #ff8, #8f8, #8ff, #88f, #f8f, #f88)' },
    { id: 'rose', swatch: '#f2b5c8' },
    { id: 'peach', swatch: '#f5c5a3' },
    { id: 'lavender', swatch: '#c8a8e9' },
    { id: 'mint', swatch: '#a8e6cf' },
    { id: 'sky', swatch: '#a8d4e6' },
    { id: 'lemon', swatch: '#f0e68c' },
    { id: 'lilac', swatch: '#d4a8e6' },
    { id: 'monochrome', swatch: 'linear-gradient(135deg, #fff, #888, #333)' },
  ];

  function openColourPicker() {
    colourGrid.innerHTML = '';
    colourOptions.forEach(opt => {
      const btn = document.createElement('button');
      btn.className = 'colour-option' + (colourMode === opt.id ? ' active' : '');
      btn.setAttribute('aria-label', opt.id);
      const swatch = document.createElement('span');
      swatch.className = 'colour-swatch';
      swatch.style.background = opt.swatch;
      btn.appendChild(swatch);
      btn.addEventListener('click', () => {
        colourMode = opt.id;
        colourOverlay.classList.remove('open');
      });
      colourGrid.appendChild(btn);
    });
    colourOverlay.classList.add('open');
  }

  document.getElementById('colourClose').addEventListener('click', () => colourOverlay.classList.remove('open'));
  colourOverlay.addEventListener('click', (e) => {
    if (e.target === colourOverlay) colourOverlay.classList.remove('open');
  });

  document.getElementById('optColour').addEventListener('click', () => {
    openColourPicker();
    closeOptions();
  });

  // ── Visualiser Menu ──
  const menuGrid = document.getElementById('menuGrid');

  function openMenu() {
    menuGrid.innerHTML = '';
    // Random button
    const randBtn = document.createElement('button');
    randBtn.className = 'menu-item menu-random';
    randBtn.textContent = 'random';
    randBtn.addEventListener('click', () => {
      currentVis = Math.floor(Math.random() * visualisers.length);
      resetVisState();
      closeMenu();
    });
    menuGrid.appendChild(randBtn);

    visualisers.forEach((v, i) => {
      const btn = document.createElement('button');
      btn.className = 'menu-item' + (i === currentVis ? ' active' : '');
      btn.textContent = v.name;
      btn.addEventListener('click', () => {
        currentVis = i;
        resetVisState();
        closeMenu();
      });
      menuGrid.appendChild(btn);
    });
    menuOverlay.classList.add('open');
  }

  function closeMenu() {
    menuOverlay.classList.remove('open');
  }

  document.getElementById('menuClose').addEventListener('click', closeMenu);
  menuOverlay.addEventListener('click', (e) => {
    if (e.target === menuOverlay) closeMenu();
  });

  function resetVisState() {
    particles = [];
    particlesSpawnAccumulator = 0;
    wfSmoothed = null;
    waveformVertical = false;
    barsSmoothed = null;
    mirrorBarsSmoothed = null;
    barsVariant = 0;
    terrainHistory = [];
    terrainFrameCount = 0;
    initStars();
    auroraTime = 0;
    kaleidoTime = 0;
    kaleidoRotation = 0;
    kaleidoSpinSpeed = 0;
    kaleidoSpinEnabled = false;
    kaleidoSpinStopping = false;
    kaleidoSpinStopAngle = null;
    kaleidoStopClickCount = 0;
    kaleidoLastUpdate = performance.now();
    raindrops = [];
    swirlTime = 0;
    swirlDirection = 1;
    fogCircles = [];
    fogCirclesW = 0;
    fogCirclesH = 0;
    starfieldOriginX = null;
    starfieldOriginY = null;
    starfieldMouseFollow = false;
    starfieldTouchDragging = false;
    starfieldTouchPointerId = null;
    starfieldReturnActive = false;
    starfieldReturnStart = 0;
    starfieldReturnFromX = 0;
    starfieldReturnFromY = 0;
    radialRotation = 0;
    radialSpinSpeed = 0;
    radialSpinEnabled = false;
    radialSpinStopping = false;
    radialSpinStopAngle = null;
    radialStopClickCount = 0;
    radialLastUpdate = performance.now();
    spectrumRotation = 0;
    spectrumSpinSpeed = 0;
    spectrumSpinEnabled = false;
    spectrumSpinStopping = false;
    spectrumSpinStopAngle = null;
    spectrumStopClickCount = 0;
    spectrumLastUpdate = performance.now();
    nightingaleRotation = 0;
    nightingaleSpinSpeed = 0;
    nightingaleSpinEnabled = false;
    nightingaleSpinStopping = false;
    nightingaleSpinStopAngle = null;
    nightingaleStopClickCount = 0;
    nightingaleLastUpdate = performance.now();
    nightingaleOuterSmoothed = null;
    nightingaleInnerSmoothed = null;
    nightingaleLagBuffer = null;
    fireworkParticles = [];
    fwCooldown = 0;
    polyHistory = [];
    polygraphShowBackground = false;
    dbHistory = [];
    dbHistoryFrame = 0;
    decibelsShowChart = false;
    peakDb = -100;
    peakHold = 0;
    clearTimeout(visNameHintTimer);
    visNameHint.classList.remove('show');

    // Always clear canvas fully on visualiser switch
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // ── Idle auto-hide ──
  let windowHasMouse = false;
  document.addEventListener('mouseenter', () => { windowHasMouse = true; });
  document.addEventListener('mouseleave', () => { windowHasMouse = false; });

  function resetIdle() {
    if (controlsHidden) {
      document.body.classList.remove('controls-hidden');
      controlsHidden = false;
    }
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      if (running && !optPanel.classList.contains('open') && !menuOverlay.classList.contains('open') && !colourOverlay.classList.contains('open')) {
        document.body.classList.add('controls-hidden');
        controlsHidden = true;
      }
    }, 2600);
  }

  const cursorEl = document.getElementById('cursor');
  // Hide custom cursor on touchscreens (JS fallback for older browsers)
  const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (isTouch) {
    cursorEl.classList.add('touch-hidden');
  } else {
    document.addEventListener('mousemove', (e) => {
      cursorEl.style.left = e.clientX + 'px';
      cursorEl.style.top = e.clientY + 'px';
      cursorEl.style.display = 'block';
      if (windowHasMouse) resetIdle();
    });
    document.addEventListener('mousedown', () => { cursorEl.classList.add('clicking'); });
    document.addEventListener('mouseup', () => { cursorEl.classList.remove('clicking'); });
    window.addEventListener('blur', () => { cursorEl.classList.remove('clicking'); });
    document.addEventListener('mouseleave', () => {
      cursorEl.style.display = 'none';
      cursorEl.classList.remove('clicking');
    });
  }
  document.addEventListener('touchstart', resetIdle, { passive: true });
  resetIdle();

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      requestWakeLock();
    } else {
      releaseWakeLock();
    }
  });
  window.addEventListener('pagehide', releaseWakeLock);
  window.addEventListener('beforeunload', releaseWakeLock);

  // ── Keyboard shortcuts ──
  document.addEventListener('keydown', (e) => {
    if (e.key === 'f' || e.key === 'F') {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    }
    if (e.key === 'ArrowRight' || e.key === 'n' || e.key === 'N') {
      currentVis = (currentVis + 1) % visualisers.length;
      resetVisState();
    }
    if (e.key === 'ArrowLeft' || e.key === 'p' || e.key === 'P') {
      currentVis = (currentVis - 1 + visualisers.length) % visualisers.length;
      resetVisState();
    }
    if (e.key === 'Escape') {
      closeMenu();
      colourOverlay.classList.remove('open');
    }
    if (e.key === 'm' || e.key === 'M') {
      if (menuOverlay.classList.contains('open')) closeMenu();
      else openMenu();
    }
  });

  // ── Swipe support for mobile ──
  let touchStartX = 0;
  document.addEventListener('touchstart', (e) => {
    if (menuOverlay.classList.contains('open') || colourOverlay.classList.contains('open')) return;
    touchStartX = e.touches[0].clientX;
  }, { passive: true });

  document.addEventListener('touchend', (e) => {
    if (menuOverlay.classList.contains('open') || colourOverlay.classList.contains('open')) return;
    const dx = e.changedTouches[0].clientX - touchStartX;
    if (Math.abs(dx) > 60) {
      if (dx < 0) {
        currentVis = (currentVis + 1) % visualisers.length;
      } else {
        currentVis = (currentVis - 1 + visualisers.length) % visualisers.length;
      }
      resetVisState();
    }
  }, { passive: true });

  // Initial resize
  resize();
})();
</script>
</body>
</html>
